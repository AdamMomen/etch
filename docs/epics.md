# NAMELESS - Epic Breakdown

**Author:** BMad
**Date:** 2025-11-30
**Project Level:** MVP
**Target Scale:** 2-10 participants per room

---

## Overview

This document provides the complete epic and story breakdown for NAMELESS, decomposing the requirements from the [PRD](./prd.md) into implementable stories.

**Living Document Notice:** This version incorporates context from PRD, UX Design, and Architecture documents.

## Epics Summary

| Epic | Title | User Value | Stories | FRs |
|------|-------|------------|---------|-----|
| **Epic 1** | Foundation & Project Setup | Enables all development work | 5 | Infrastructure |
| **Epic 2** | Basic Meeting Experience | Users can create/join rooms and communicate via A/V | 14 | FR1-4, FR6-14, FR44-47, FR53-56 |
| **Epic 3** | Screen Sharing | Users can share and view screens in meetings + floating control bar | 10 | FR15-26 |
| **Epic 4** | Real-Time Annotations | Users can draw on shared screens (CORE VALUE) | 11 | FR27-30, FR33-36 |
| **Epic 5** | Permissions & Moderation | Hosts can manage meetings and control annotations | 8 | FR5, FR31-32, FR37-43 |
| **Epic 6** | Connection Resilience | Users stay connected and recover from network issues | 7 | FR48-52 |
| **Epic 7** | Self-Hosting & Deployment | Teams can deploy their own NAMELESS instance | 9 | FR57-62 |

**Total: 7 Epics, 64 Stories, 62 Functional Requirements**

---

## Functional Requirements Inventory

### Meeting & Room Management (FR1-7)
- **FR1:** Users can create a new meeting room with a single action
- **FR2:** Users can join an existing room via shareable link
- **FR3:** Users can set a display name when joining a room
- **FR4:** Hosts can generate and share room invite links
- **FR5:** Hosts can remove participants from the room
- **FR6:** Users can leave a meeting at any time
- **FR7:** Rooms are automatically cleaned up when all participants leave

### Audio & Video (FR8-14)
- **FR8:** Users can publish audio from their microphone
- **FR9:** Users can publish video from their camera
- **FR10:** Users can mute/unmute their own audio
- **FR11:** Users can enable/disable their own video
- **FR12:** Users can select which microphone and camera to use
- **FR13:** Users can see and hear other participants' audio/video streams
- **FR14:** Users can adjust volume of individual participants (local mix)

### Screen Sharing (FR15-26)
- **FR15:** Users can share their entire screen
- **FR16:** Users can share a specific application window
- **FR17:** Users can stop screen sharing at any time
- **FR18:** Only one participant can share screen at a time (MVP)
- **FR19:** All participants can view the shared screen
- **FR20:** Shared screen displays at appropriate quality for content visibility
- **FR21:** When sharing begins, the main Nameless window automatically minimizes and the shared window/screen is focused
- **FR22:** A visual border appears around the shared window/screen to indicate active sharing
- **FR23:** A floating control bar appears on top of all windows showing sharing status, participant face circles, and meeting controls
- **FR24:** The floating control bar remains visible across all screens/desktops when the main application is minimized
- **FR25:** The floating control bar can be repositioned by dragging
- **FR26:** The floating control bar provides quick access to: mute/unmute, camera toggle, stop sharing, and leave meeting

### Annotation System (FR27-36)
- **FR27:** Users with annotator permissions can draw freehand strokes on shared screens
- **FR28:** Users can use a pen tool for precise line drawing
- **FR29:** Users can use a highlighter tool for semi-transparent emphasis
- **FR30:** Users can use an eraser tool to remove their own strokes
- **FR31:** Hosts can clear all annotations from the shared screen
- **FR32:** Sharers can delete any annotation on their shared screen
- **FR33:** Annotations appear in real-time for all participants (< 200ms latency)
- **FR34:** Each participant's annotations display in a distinct color
- **FR35:** Late-joining participants see all existing annotations immediately
- **FR36:** Annotations are resolution-independent (scale correctly on different displays)

### Permission & Roles (FR37-43)
- **FR37:** Room creator is automatically assigned the Host role
- **FR38:** Hosts can assign roles to other participants (Annotator, Viewer)
- **FR39:** Hosts can enable or disable annotation capability for the room
- **FR40:** Annotators can create and delete their own annotations
- **FR41:** Viewers can observe the meeting but cannot annotate
- **FR42:** Sharers have elevated permissions on their own shared content
- **FR43:** Users can see their current role and permissions clearly

### Authentication & Access (FR44-47)
- **FR44:** Rooms use token-based authentication for access control
- **FR45:** Users do not need to create an account to join meetings
- **FR46:** Room tokens can be generated by the self-hosted server
- **FR47:** Invalid or expired tokens are rejected with clear error messages

### Connection & State Management (FR48-52)
- **FR48:** Application automatically reconnects after brief network interruptions
- **FR49:** Annotation state is preserved and restored after reconnection
- **FR50:** Users receive clear feedback when connection is lost
- **FR51:** Users receive notification when reconnection succeeds
- **FR52:** Application handles graceful degradation during poor network conditions

### Desktop Application (FR53-58)
- **FR53:** Application runs on macOS (Intel and Apple Silicon)
- **FR54:** Application runs on Windows 10 and 11
- **FR55:** Application requests necessary system permissions (screen capture, microphone, camera)
- **FR56:** Application stores user preferences locally
- **FR57:** Application displays notification when updates are available
- **FR58:** Users can access recent rooms from the application

### Self-Hosting & Deployment (FR59-62)
- **FR59:** Server can be deployed via Docker Compose with minimal configuration
- **FR60:** Server integrates with self-hosted LiveKit instance
- **FR61:** Deployment documentation enables setup without external support
- **FR62:** Server provides health check endpoints for monitoring

---

## FR Coverage Map

| Epic | Functional Requirements Covered |
|------|--------------------------------|
| **Epic 1: Foundation** | Infrastructure for all FRs (FR53, FR54 partial) |
| **Epic 2: Basic Meeting** | FR1, FR2, FR3, FR4, FR6, FR7, FR8-14, FR44-47, FR53-56 |
| **Epic 3: Screen Sharing** | FR15-26 (includes floating control bar, share border, auto-minimize) |
| **Epic 4: Annotations** | FR27, FR28, FR29, FR30, FR33, FR34, FR35, FR36 |
| **Epic 5: Permissions** | FR5, FR31, FR32, FR37, FR38, FR39, FR40, FR41, FR42, FR43 |
| **Epic 6: Connection Resilience** | FR48, FR49, FR50, FR51, FR52 |
| **Epic 7: Self-Hosting** | FR57, FR58, FR59, FR60, FR61, FR62 |

**Coverage Validation:** ✅ All 62 FRs mapped to at least one epic.

---

## Epic 1: Foundation & Project Setup

**Goal:** Establish the development foundation - monorepo structure, Tauri app shell, API server skeleton, shared types, and development tooling that enables all subsequent work.

**User Value:** Enables all development work (necessary foundation for greenfield project)

**FRs Addressed:** Infrastructure for all FRs (FR47, FR48 partial)

---

### Story 1.1: Initialize Monorepo with Tauri Desktop App

**As a** developer,
**I want** a properly structured monorepo with a working Tauri desktop application,
**So that** I have a foundation to build all NAMELESS features upon.

**Acceptance Criteria:**

**Given** a fresh clone of the repository
**When** I run `pnpm install && pnpm dev:client`
**Then** a Tauri desktop window opens with a basic React UI

**And** the project structure matches the architecture specification:
```
nameless/
├── packages/
│   ├── client/          # Tauri desktop app
│   │   ├── src/         # React frontend
│   │   └── src-tauri/   # Rust backend
│   ├── server/          # Hono API server
│   └── shared/          # Shared types & utilities
├── pnpm-workspace.yaml
└── package.json
```

**And** TypeScript is configured with path aliases (`@/` for client, `@nameless/shared`)
**And** Tailwind CSS is configured with the design system tokens from UX spec
**And** shadcn/ui is initialized with dark mode as default
**And** ESLint and Prettier are configured for consistent code style
**And** the app builds successfully for macOS (`pnpm build:client`)

**Prerequisites:** None (first story)

**Technical Notes:**
- Use `npx create-tauri-ui@latest` as starter (per Architecture doc)
- Select Vite + React template with pnpm
- Configure `tsconfig.base.json` for shared TypeScript settings
- Set up path aliases in both Vite and TypeScript configs
- Install Lucide icons (included with shadcn/ui)
- Configure tauri-controls for native window controls

---

### Story 1.2: Configure Hono API Server with Health Endpoint

**As a** developer,
**I want** a minimal Hono API server in the monorepo,
**So that** I have a backend ready for room management and token generation.

**Acceptance Criteria:**

**Given** the monorepo from Story 1.1
**When** I run `pnpm dev:server`
**Then** the Hono server starts on port 3000

**And** `GET /api/health` returns:
```json
{
  "status": "ok",
  "timestamp": 1732968000000
}
```
with status 200

**And** the server uses TypeScript with ES modules
**And** environment variables are loaded from `.env` file
**And** the server has structured JSON logging to stdout
**And** CORS is configured for local development

**Prerequisites:** Story 1.1

**Technical Notes:**
- Use Hono 4.x with `@hono/node-server`
- Add `zod` for request validation (used later)
- Configure environment variables: `PORT`, `LIVEKIT_URL`, `LIVEKIT_API_KEY`, `LIVEKIT_API_SECRET`
- Create `.env.example` with placeholder values
- Server file structure per Architecture: `src/routes/`, `src/services/`, `src/middleware/`

---

### Story 1.3: Create Shared Types Package

**As a** developer,
**I want** shared TypeScript types available to both client and server,
**So that** type safety is maintained across the entire codebase.

**Acceptance Criteria:**

**Given** the monorepo structure
**When** I import from `@nameless/shared` in client or server code
**Then** I have access to all shared types and constants

**And** the following types are defined:
```typescript
// Point and Stroke types
interface Point { x: number; y: number; pressure?: number; }
interface Stroke { id: string; participantId: string; tool: 'pen' | 'highlighter'; color: string; points: Point[]; createdAt: number; }

// Room and Participant types
type Role = 'host' | 'sharer' | 'annotator' | 'viewer';
interface Participant { id: string; name: string; role: Role; color: string; isLocal: boolean; }
interface RoomState { id: string; participants: Participant[]; isScreenSharing: boolean; sharerId: string | null; annotationsEnabled: boolean; }

// API types
interface CreateRoomRequest { hostName: string; }
interface CreateRoomResponse { roomId: string; token: string; livekitUrl: string; }
interface JoinRoomRequest { participantName: string; role?: Role; }
interface JoinRoomResponse { token: string; livekitUrl: string; }
interface ApiError { error: { code: string; message: string; } }
```

**And** constants are defined:
```typescript
const PARTICIPANT_COLORS = ['#f97316', '#06b6d4', '#a855f7', '#22c55e', '#ec4899'];
const MAX_STROKE_POINTS = 10000;
const MAX_PARTICIPANTS = 10;
```

**And** the package is properly configured for TypeScript with `"type": "module"`

**Prerequisites:** Story 1.1

**Technical Notes:**
- Package location: `packages/shared/`
- Export all types from `src/index.ts`
- Types match Architecture doc Section "Data Architecture"
- Colors match UX spec Section 3.1 "Annotation Colors"

---

### Story 1.4: Set Up Vitest Testing Framework

**As a** developer,
**I want** a testing framework configured across the monorepo,
**So that** I can write and run tests for all packages.

**Acceptance Criteria:**

**Given** the monorepo with client, server, and shared packages
**When** I run `pnpm test`
**Then** Vitest runs all tests across all packages

**And** each package can run tests independently:
- `pnpm test:client` - runs client tests
- `pnpm test:server` - runs server tests
- `pnpm test:shared` - runs shared tests

**And** test files are co-located with source files (`*.test.ts`)
**And** React Testing Library is configured for component tests
**And** coverage reports are generated with `pnpm test:coverage`
**And** at least one passing test exists in each package (placeholder tests)

**Prerequisites:** Story 1.1, 1.2, 1.3

**Technical Notes:**
- Use Vitest (native Vite integration)
- Configure `vitest.workspace.ts` for monorepo
- Add `@testing-library/react` and `@testing-library/jest-dom` for client
- Add `jsdom` environment for client tests
- Test file pattern: `**/*.test.ts`, `**/*.test.tsx`

**Sprint 0 Test Infrastructure Requirements:**

Per System-Level Test Design (`docs/test-design-system.md`), this story must establish:

**1. Configuration Structure:**
```
packages/
├── client/
│   ├── vitest.config.ts      # jsdom environment, React plugin
│   └── src/test/setup.ts     # RTL cleanup, window mocks
├── server/
│   └── vitest.config.ts      # node environment
├── shared/
│   └── vitest.config.ts      # node environment
└── vitest.workspace.ts       # Workspace config (runs all)
```

**2. Test Data Factories (in `@nameless/shared`):**
- [ ] `createMockStroke(overrides?)` - Creates stroke with sensible defaults
- [ ] `createMockParticipant(overrides?)` - Creates participant with role
- [ ] `createMockHost()`, `createMockViewer()` - Role-specific helpers
- [ ] `createStrokeStartMessage()`, `createSyncResponseMessage()` - Message factories

**3. Mock Infrastructure (in `@nameless/client`):**
- [ ] `MockLiveKitRoom` - Simulates room connection, data events, participants
- [ ] `MockDataTrackSync` - Simulates publish/subscribe with test helpers
- [ ] Store helpers: `resetAllStores()`, `seedStrokes()`, `getAnnotationState()`

**4. Coverage Thresholds:**
```typescript
// vitest.config.ts coverage settings
thresholds: {
  lines: 60,      // Initial threshold
  branches: 60,
  functions: 60,
  statements: 60,
}
// Critical paths (stores, utils): 80% target (enforced per-epic)
```

**5. Test Setup File Requirements:**
```typescript
// packages/client/src/test/setup.ts must include:
- @testing-library/jest-dom matchers
- afterEach cleanup
- window.matchMedia mock (dark mode)
- ResizeObserver mock (canvas)
```

**6. Package.json Scripts:**
```json
{
  "test": "vitest run",
  "test:watch": "vitest",
  "test:coverage": "vitest run --coverage",
  "test:ui": "vitest --ui"
}
```

**Definition of Done Checklist:**
- [ ] `vitest.workspace.ts` configured at root
- [ ] Each package has `vitest.config.ts` with appropriate environment
- [ ] Client test setup file with all mocks
- [ ] Test factories created and exported from `@nameless/shared`
- [ ] Mock infrastructure created in `@nameless/client`
- [ ] Coverage thresholds configured (60% initial)
- [ ] At least one passing test per package
- [ ] `pnpm test:coverage` generates HTML report

---

### Story 1.5: Configure Development Scripts and Tooling

**As a** developer,
**I want** convenient development scripts to run the full stack,
**So that** I can develop efficiently with hot reload.

**Acceptance Criteria:**

**Given** the monorepo with all packages configured
**When** I run `pnpm dev`
**Then** both the Tauri client (with hot reload) and Hono server start concurrently

**And** the following scripts are available in root `package.json`:
```json
{
  "dev": "concurrently \"pnpm dev:client\" \"pnpm dev:server\"",
  "dev:client": "pnpm --filter client dev",
  "dev:server": "pnpm --filter server dev",
  "build": "pnpm build:client && pnpm build:server",
  "build:client": "pnpm --filter client build",
  "build:server": "pnpm --filter server build",
  "test": "vitest run",
  "test:watch": "vitest",
  "test:coverage": "vitest run --coverage",
  "typecheck": "tsc --noEmit",
  "lint": "eslint packages/*/src --ext .ts,.tsx",
  "lint:fix": "eslint packages/*/src --ext .ts,.tsx --fix",
  "format": "prettier --write \"packages/*/src/**/*.{ts,tsx,css}\""
}
```

**And** VS Code settings are configured for the project (`.vscode/settings.json`)
**And** recommended extensions are listed (`.vscode/extensions.json`)

**Prerequisites:** Story 1.1, 1.2, 1.3, 1.4

**Technical Notes:**
- Use `concurrently` for parallel script execution
- Configure VS Code for ESLint, Prettier, Tailwind CSS IntelliSense
- Recommended extensions: dbaeumer.vscode-eslint, esbenp.prettier-vscode, bradlc.vscode-tailwindcss, rust-lang.rust-analyzer, tauri-apps.tauri-vscode

---

## Epic 2: Basic Meeting Experience

**Goal:** Enable users to create and join meeting rooms with audio/video communication - a fully functional video conferencing experience.

**User Value:** After this epic, users can hold video meetings with others.

**FRs Addressed:** FR1-4, FR6-14, FR38-41, FR47-50

---

### Story 2.1: Implement Room Creation API Endpoint

**As a** user,
**I want** to create a new meeting room with a single action,
**So that** I can quickly start a meeting and invite others.

**Acceptance Criteria:**

**Given** the API server is running
**When** I send `POST /api/rooms` with body `{ "hostName": "BMad" }`
**Then** I receive status 201 with response:
```json
{
  "roomId": "abc-123-xyz",
  "token": "eyJhbGciOiJIUzI1NiIs...",
  "livekitUrl": "wss://localhost:7880"
}
```

**And** the roomId is a unique, URL-safe string (format: `xxx-xxx-xxx`)
**And** the token is a valid LiveKit JWT with:
  - `identity`: unique participant ID
  - `name`: "BMad"
  - `metadata`: `{ "role": "host", "color": "#f97316" }`
  - `exp`: 1 hour from now
  - Room permissions: `roomJoin: true`, `canPublish: true`

**And** invalid requests return 400 with error:
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "hostName is required"
  }
}
```

**Prerequisites:** Story 1.2, 1.3

**Technical Notes:**
- Use `livekit-server-sdk` for token generation
- Room ID generation: `nanoid` with custom alphabet (lowercase + numbers, no ambiguous chars)
- Store active rooms in memory (Map) for MVP - no database needed
- Token expiry: 1 hour (configurable via env)

---

### Story 2.2: Implement Room Join API Endpoint

**As a** user,
**I want** to join an existing meeting room via a shareable link,
**So that** I can participate in meetings others have created.

**Acceptance Criteria:**

**Given** a room "abc-123-xyz" exists
**When** I send `POST /api/rooms/abc-123-xyz/join` with body `{ "participantName": "Alice" }`
**Then** I receive status 200 with response:
```json
{
  "token": "eyJhbGciOiJIUzI1NiIs...",
  "livekitUrl": "wss://localhost:7880"
}
```

**And** the token has:
  - `identity`: unique participant ID
  - `name`: "Alice"
  - `metadata`: `{ "role": "annotator", "color": "#06b6d4" }` (next available color)
  - Room permissions: `roomJoin: true`, `canPublish: true`

**And** joining a non-existent room returns 404:
```json
{
  "error": {
    "code": "ROOM_NOT_FOUND",
    "message": "The requested room does not exist or has ended"
  }
}
```

**And** the participant color is assigned from the pool, cycling through available colors

**Prerequisites:** Story 2.1

**Technical Notes:**
- Default role for joiners is "annotator" (can be overridden to "viewer")
- Color assignment: cycle through PARTICIPANT_COLORS array based on join order
- Validate roomId format before lookup

---

### Story 2.3: Build Home Screen with Create/Join Meeting UI

**As a** user,
**I want** a home screen where I can create a new meeting or join an existing one,
**So that** I have a clear entry point to start using NAMELESS.

**Acceptance Criteria:**

**Given** I launch the NAMELESS application
**When** the app opens
**Then** I see the home screen with:
  - NAMELESS logo/title
  - "Start Meeting" primary button
  - "Join Meeting" input field with room code/link
  - "Join" button (enabled when input has value)

**And** clicking "Start Meeting" shows a brief loading state then navigates to the meeting room
**And** entering a room code and clicking "Join" shows name input dialog then navigates to room
**And** the UI matches the UX spec dark theme (`--background: #09090b`)
**And** the "Start Meeting" button has accent color (`--accent: #8b5cf6`)
**And** keyboard shortcut `Enter` submits the join form when focused

**Prerequisites:** Story 1.1, 2.1, 2.2

**Technical Notes:**
- Use shadcn/ui Button, Input components
- Store API base URL in settings (defaults to localhost:3000 for dev)
- Room code input accepts both full URLs and just the room ID
- Parse room ID from URL format: `nameless://room/{id}` or `https://*/room/{id}`

---

### Story 2.4: Implement Join Meeting Flow with Name Input

**As a** user,
**I want** to enter my display name when joining a meeting,
**So that** other participants can identify me.

**Acceptance Criteria:**

**Given** I click "Join" with a valid room code
**When** the join dialog appears
**Then** I see:
  - "Join Meeting" title with room ID displayed
  - "Your name" input field (pre-filled if I've joined before)
  - "Join" primary button
  - "Cancel" secondary button

**And** the name input has:
  - Minimum 1 character, maximum 50 characters
  - Focus on open (auto-focus)
  - Validation error shown below input if empty on submit

**And** clicking "Join" with valid name:
  - Shows loading spinner on button
  - Calls join API
  - Navigates to meeting room on success
  - Shows error toast on failure

**And** my name is saved to localStorage for next time
**And** pressing `Enter` in the name field submits the form

**Prerequisites:** Story 2.3

**Technical Notes:**
- Use shadcn/ui Dialog, Input, Button components
- localStorage key: `nameless_display_name`
- Error toast duration: 5 seconds per UX spec
- Loading state disables button and shows spinner

---

### Story 2.5: Create Meeting Room Layout Shell

**As a** user,
**I want** a meeting room interface that shows participants and meeting controls,
**So that** I have a clear view of who's in the meeting and how to interact.

**Acceptance Criteria:**

**Given** I've joined a meeting room
**When** the meeting room view loads
**Then** I see the layout per UX spec Direction #1 (Hybrid):
  - Left sidebar: collapsible, shows participant list
  - Center: main content area (will show video/screen share)
  - Top toolbar: annotation tools area (disabled until screen share)
  - Bottom: meeting controls bar

**And** the sidebar shows:
  - "PARTICIPANTS" header
  - List of participants with avatar, name, role badge
  - My entry marked with "(You)"
  - "Invite" button at bottom

**And** the meeting controls bar shows:
  - Microphone toggle button (muted by default, with slash icon)
  - Camera toggle button (off by default, with slash icon)
  - Screen share button (outline style)
  - Leave button (red/destructive style)

**And** the sidebar can be toggled with `⌘\` (Ctrl+\ on Windows)
**And** the layout is responsive per UX spec (sidebar auto-collapses < 1000px width)

**Prerequisites:** Story 2.4, 1.3

**Technical Notes:**
- Use Zustand `roomStore` for room state (participants, local user)
- Implement ParticipantListItem component per UX spec Section 6
- Implement MeetingControlsBar component per UX spec Section 6
- Use CSS Grid or Flexbox for responsive layout
- Sidebar state persisted to localStorage

---

### Story 2.6: Integrate LiveKit Room Connection

**As a** user,
**I want** to connect to the meeting room via LiveKit,
**So that** I can communicate with other participants in real-time.

**Acceptance Criteria:**

**Given** I have a valid LiveKit token from the join API
**When** I enter the meeting room
**Then** the client connects to LiveKit using the token

**And** on successful connection:
  - Connection status indicator shows green dot with "Connected"
  - My participant appears in the participant list
  - Other participants in the room appear in the list

**And** when another participant joins:
  - They appear in the participant list within 2 seconds
  - A subtle toast shows "{name} joined"

**And** when a participant leaves:
  - They are removed from the participant list
  - A subtle toast shows "{name} left"

**And** on connection failure:
  - Status indicator shows red dot with "Disconnected"
  - Error toast with "Failed to connect" and retry option

**Prerequisites:** Story 2.5

**Technical Notes:**
- Use `livekit-client` Room class
- Use `@livekit/components-react` hooks where helpful
- Listen to RoomEvent.ParticipantConnected, ParticipantDisconnected
- Extract participant metadata (role, color) from token
- Update Zustand roomStore on participant changes

---

### Story 2.7: Implement Audio Publishing and Controls

**As a** user,
**I want** to publish my microphone audio and control mute/unmute,
**So that** I can speak to other participants in the meeting.

**Acceptance Criteria:**

**Given** I'm connected to a LiveKit room
**When** I click the microphone button (currently muted)
**Then** the system prompts for microphone permission (if not granted)

**And** after permission granted:
  - Microphone audio is published to the room
  - Button icon changes from muted (slash) to unmuted
  - Other participants can hear me

**And** clicking the microphone button again:
  - Mutes the audio track (stops publishing)
  - Button icon shows muted state (slash)

**And** the mute/unmute toggle is instant (< 100ms visual feedback)
**And** keyboard shortcut `M` toggles mute state
**And** if permission denied, show toast: "Microphone access denied. Check system settings."

**Prerequisites:** Story 2.6

**Technical Notes:**
- Use `room.localParticipant.setMicrophoneEnabled()`
- Request permission via Tauri's permission APIs or browser API
- Store preference in settingsStore (start muted by default per UX spec)
- Add speaking indicator animation on participant avatar when audio detected

---

### Story 2.8: Implement Video Publishing and Controls

**As a** user,
**I want** to publish my camera video and control on/off,
**So that** other participants can see me during the meeting.

**Acceptance Criteria:**

**Given** I'm connected to a LiveKit room
**When** I click the camera button (currently off)
**Then** the system prompts for camera permission (if not granted)

**And** after permission granted:
  - Camera video is published to the room
  - Button icon changes from off (slash) to on
  - My video appears in the participant area

**And** clicking the camera button again:
  - Stops the video track
  - Button icon shows off state (slash)
  - Video element shows avatar/placeholder

**And** keyboard shortcut `V` toggles video state
**And** if permission denied, show toast: "Camera access denied. Check system settings."

**Prerequisites:** Story 2.7

**Technical Notes:**
- Use `room.localParticipant.setCameraEnabled()`
- Video off by default per UX spec (less intimidating)
- Show gradient avatar with initial when video off
- Video resolution: 720p default (can be lower on poor network)

---

### Story 2.9: Display Remote Participant Audio/Video Streams

**As a** user,
**I want** to see and hear other participants' audio and video,
**So that** I can communicate face-to-face in the meeting.

**Acceptance Criteria:**

**Given** I'm in a meeting with other participants
**When** a remote participant has video enabled
**Then** their video displays in the participant area

**And** when a remote participant has audio enabled:
  - I can hear their audio
  - Their avatar shows speaking indicator when they talk

**And** when a remote participant disables video:
  - Their video is replaced with avatar placeholder
  - Transition is smooth (fade)

**And** participant videos are displayed as:
  - Floating bubbles (Around-style) when screen sharing is active
  - Grid layout when no screen share (up to 10 participants)

**And** video quality adapts to network conditions automatically

**Prerequisites:** Story 2.8

**Technical Notes:**
- Use LiveKit's automatic track subscription
- Implement ParticipantBubble component per UX spec
- Use `<VideoTrack>` or `<AudioTrack>` from @livekit/components-react
- Grid layout: 2x2 for 4 or fewer, 3x3 for 5-9, etc.
- Simulcast enabled for adaptive quality

---

### Story 2.10: Implement Device Selection for Microphone and Camera

**As a** user,
**I want** to select which microphone and camera to use,
**So that** I can use my preferred devices for the meeting.

**Acceptance Criteria:**

**Given** I'm in a meeting
**When** I click a dropdown arrow next to the microphone button
**Then** I see a list of available microphones with:
  - Device names
  - Checkmark on currently selected device
  - "System Default" option at top

**And** selecting a different microphone:
  - Switches to that device immediately
  - Shows brief "Switched to {device}" toast
  - Persists selection for future meetings

**And** the same pattern works for camera selection (dropdown next to camera button)
**And** if a device is disconnected mid-meeting:
  - Fallback to default device
  - Show toast: "Device disconnected, switched to {default}"

**Prerequisites:** Story 2.8

**Technical Notes:**
- Use `navigator.mediaDevices.enumerateDevices()`
- Use shadcn/ui DropdownMenu component
- Store device preferences in settingsStore (localStorage)
- Listen for `devicechange` event to update list
- Use `room.switchActiveDevice()` for switching

---

### Story 2.11: Implement Participant Volume Control

**As a** user,
**I want** to adjust the volume of individual participants,
**So that** I can balance audio levels to my preference.

**Acceptance Criteria:**

**Given** I'm in a meeting with other participants
**When** I hover over a participant in the sidebar
**Then** I see a volume slider icon appear

**And** clicking the volume icon shows a volume slider (0-100%)
**And** dragging the slider adjusts that participant's audio volume locally
**And** setting volume to 0 effectively mutes them (for me only)
**And** volume changes are instant (no delay)
**And** volume settings persist for the session (reset on rejoin)

**Prerequisites:** Story 2.9

**Technical Notes:**
- Use Web Audio API gain node for per-participant volume
- Or use LiveKit's `setVolume()` method on audio tracks
- shadcn/ui Slider component for volume control
- Default volume: 100%
- Volume range: 0-200% (allow boost)

---

### Story 2.12: Implement Leave Meeting Flow

**As a** user,
**I want** to leave a meeting at any time,
**So that** I can exit when I'm done participating.

**Acceptance Criteria:**

**Given** I'm in a meeting
**When** I click the "Leave" button
**Then** if I'm a regular participant:
  - I immediately disconnect from the room
  - I'm returned to the home screen
  - Other participants see "{name} left" notification

**And** if I'm the host:
  - I see confirmation dialog: "Leave meeting? You are the host. The meeting will continue without you."
  - "Leave" confirms and disconnects
  - "Cancel" returns to meeting
  - Host role transfers to next participant (by join order)

**And** keyboard shortcut `⌘W` (Ctrl+W) triggers leave
**And** closing the window also triggers leave flow

**Prerequisites:** Story 2.6

**Technical Notes:**
- Use `room.disconnect()` to cleanly leave
- Host transfer: update participant metadata via DataTrack message
- Window close: listen to Tauri window close event, disconnect first
- Return to home screen via React Router or state change

---

### Story 2.13: Implement Room Invite Link Generation and Sharing

**As a** host,
**I want** to generate and share invite links,
**So that** I can invite others to join my meeting.

**Acceptance Criteria:**

**Given** I'm in a meeting (as host or participant)
**When** I click the "Invite" button in the sidebar
**Then** I see an invite modal with:
  - Room link displayed (e.g., `nameless://room/abc-123-xyz`)
  - "Copy Link" button
  - QR code (optional, nice-to-have)

**And** clicking "Copy Link":
  - Copies the link to clipboard
  - Shows toast: "Link copied!"
  - Button text briefly changes to "Copied!"

**And** the link auto-copies to clipboard when room is first created
**And** keyboard shortcut `⌘I` (Ctrl+I) opens invite modal

**Prerequisites:** Story 2.5

**Technical Notes:**
- Use Tauri clipboard API or `navigator.clipboard`
- shadcn/ui Dialog for modal
- Link format configurable (custom domain for self-hosted)
- Store server URL in settings for link generation

---

### Story 2.14: Implement User Preferences Storage

**As a** user,
**I want** my preferences saved locally,
**So that** I don't have to reconfigure settings every time I use the app.

**Acceptance Criteria:**

**Given** I've used NAMELESS before
**When** I launch the app again
**Then** my preferences are restored:
  - Display name (pre-filled in join dialog)
  - Preferred microphone device
  - Preferred camera device
  - Sidebar collapsed/expanded state
  - Theme preference (dark/light)

**And** preferences persist across app restarts
**And** preferences can be cleared/reset from a settings menu
**And** preferences are stored locally only (no server sync)

**Prerequisites:** Story 2.10

**Technical Notes:**
- Use Zustand with `persist` middleware for settingsStore
- Storage: localStorage (or Tauri's store plugin for native)
- Settings structure in shared types
- Add basic settings menu accessible from home screen

---

## Epic 3: Screen Sharing

**Goal:** Enable users to share their screen or specific windows so others can see what they're working on - including the floating control bar and share border indicator that keep sharers in control while their main window is minimized.

**User Value:** After this epic, users can share their screens in meetings with a professional UX - the main window minimizes, a floating control bar provides meeting controls, and a border indicator shows what's being captured.

**FRs Addressed:** FR15-26 (Screen Sharing + Floating Control Bar + Share Border + Auto-Minimize)

---

### Story 3.1: Implement Screen Share Initiation (Hybrid Capture)

**As a** user,
**I want** to share my entire screen or a specific window,
**So that** other participants can see what I'm working on.

**Acceptance Criteria:**

**Given** I'm in a meeting room
**When** I click the "Share Screen" button
**Then** the system shows the native screen/window picker dialog

**And** the picker shows:
  - List of available screens (for multi-monitor setups)
  - List of open application windows
  - Preview thumbnails where supported

**And** after selecting a screen/window:
  - Screen capture starts immediately
  - **Main Nameless window automatically minimizes**
  - **Selected window/screen is focused (brought to foreground)**
  - Screen share track is published to LiveKit at 1080p/VP9/4-6Mbps
  - Floating control bar appears (Story 3.7)
  - Share border indicator appears (Story 3.8)
  - My participant entry shows "Sharing" badge

**And** if I cancel the picker:
  - No screen share starts
  - Main window stays open
  - Button remains in default state

**And** keyboard shortcut `⌘S` (Ctrl+S) triggers share flow

**Prerequisites:** Story 2.6, Story 3.10 (for macOS/Linux)

**Technical Notes:**
- **Hybrid capture approach** (per Architecture ADR-007, updated 2025-12-01):
  - **Windows:** Use WebView `getDisplayMedia()` API (WebView2 has full WebRTC support)
  - **macOS/Linux:** Use Rust sidecar for native capture (Story 3.10) - WKWebView doesn't support getDisplayMedia
- Resolution: 1080p with VP9 codec at 4-6 Mbps (optimized for text clarity)
- Use `room.localParticipant.setScreenShareEnabled()` or create screen track manually
- Request with `{ video: true, audio: true }` for system audio option
- Hardware-accelerated capture at 60fps target
- LiveKit handles encoding and transmission
- Use Tauri window API to minimize main window after share starts
- Focus the shared window/screen using platform APIs

---

### Story 3.10: Implement Rust Screen Capture Sidecar (macOS/Linux)

**As a** macOS or Linux user,
**I want** screen sharing to work on my platform,
**So that** I can share my screen with the same quality as Windows users.

**Acceptance Criteria:**

**Given** I'm on macOS or Linux
**When** the app detects my platform at runtime
**Then** screen capture uses the Rust sidecar instead of WebView getDisplayMedia

**And** the sidecar provides:
  - Native screen capture via `xcap` or `scrap` Rust crates
  - Screen/window picker UI (native dialog)
  - VP9 encoding at 1080p / 4-6 Mbps bitrate
  - Frame streaming to LiveKit via custom video track

**And** the capture quality matches Windows:
  - 1080p resolution (minimum)
  - VP9 codec for text clarity
  - 4-6 Mbps bitrate target
  - 60fps capable

**And** on macOS:
  - Screen recording permission is requested if not granted
  - Permission dialog shows "NAMELESS wants to record this Mac's screen"
  - User can grant permission in System Preferences

**And** the sidecar lifecycle is managed:
  - Sidecar spawns when screen share starts
  - Sidecar terminates when screen share stops
  - Graceful fallback if sidecar fails to start (error message, suggest Windows)

**Prerequisites:** Story 1.1 (monorepo structure)

**Technical Notes:**
- Create `packages/capture-sidecar/` Rust binary
- Use Tauri's sidecar management via `tauri-plugin-shell`
- Recommended crates:
  - `xcap` - Cross-platform screen capture (used by tauri-plugin-screenshots)
  - `scrap` - From RustDesk, proven at scale for remote desktop
  - `vpx-encode` or similar for VP9 encoding
- IPC between sidecar and Tauri main process via stdin/stdout or local socket
- Stream encoded frames to LiveKit using custom video track API
- Handle macOS screen recording permission via `CGPreflightScreenCaptureAccess()` / `CGRequestScreenCaptureAccess()`
- Linux may need X11/Wayland detection for proper capture API selection

**FRs Addressed:** FR15, FR16, FR20 (platform-specific implementation)

---

### Story 3.2: Display Shared Screen for Viewers

**As a** participant,
**I want** to see the shared screen clearly in the meeting,
**So that** I can follow along with what the sharer is presenting.

**Acceptance Criteria:**

**Given** another participant is sharing their screen
**When** the screen share starts
**Then** the shared screen displays in the main content area

**And** the display behavior:
  - Screen content fills available space while maintaining aspect ratio
  - Letterbox/pillarbox with dark background (`--background`) if aspect doesn't match
  - Minimum 16px padding on all sides
  - Resolution adapts to available window size

**And** participant videos switch to floating bubbles (Around-style):
  - Small circular avatars (32px) stacked in corner
  - Don't obscure shared content
  - Position: bottom-right corner by default

**And** the sharer's name is displayed: "BMad is sharing"
**And** video quality automatically adapts to network conditions

**Prerequisites:** Story 3.1, 2.9

**Technical Notes:**
- Subscribe to screen share track via LiveKit
- Use `<VideoTrack>` component for rendering
- Implement ScreenShareViewer component
- CSS object-fit: contain for aspect ratio preservation
- Track type: `Track.Source.ScreenShare`

---

### Story 3.3: Implement Stop Screen Sharing

**As a** sharer,
**I want** to stop sharing my screen at any time,
**So that** I can regain privacy when done presenting.

**Acceptance Criteria:**

**Given** I'm currently sharing my screen
**When** I click "Stop Sharing" on the **floating control bar**
**Then** screen capture stops immediately

**And** the sharer's UI updates:
  - **Floating control bar is dismissed**
  - **Share border indicator is dismissed**
  - **Annotation overlay is dismissed**
  - **Main Nameless window restores from minimized state**
  - Button returns to "Share Screen" state (outline style)
  - "Sharing" badge removed from my participant entry

**And** other participants see:
  - Shared screen disappears
  - Toast: "{name} stopped sharing"
  - Layout returns to video grid
  - Participant videos return from floating bubbles to grid

**And** pressing `⌘S` again while sharing also stops sharing
**And** if browser/OS stops the capture (user clicked "Stop sharing" in system UI):
  - App detects this and updates state accordingly
  - All native windows (floating bar, border, overlay) are dismissed
  - Main window restores

**Prerequisites:** Story 3.1, 3.2, 3.7, 3.8

**Technical Notes:**
- Use `room.localParticipant.setScreenShareEnabled(false)`
- Listen to track ended event for system-initiated stops
- Clean up all Tauri native windows: floating control bar, share border, annotation overlay
- Restore main window using Tauri window API
- Smooth transition animation when switching layouts

---

### Story 3.4: Enforce Single Active Screen Share

**As a** meeting participant,
**I want** only one person to share at a time,
**So that** there's no confusion about what content to focus on.

**Acceptance Criteria:**

**Given** someone is already sharing their screen
**When** I try to share my screen
**Then** I see a message: "Someone is already sharing. Ask them to stop first."

**And** the "Share Screen" button is disabled (50% opacity)
**And** tooltip on hover: "{name} is currently sharing"
**And** when the current sharer stops:
  - Button becomes enabled again
  - I can now initiate screen share

**And** if I'm the host, I have option to take over (post-MVP consideration)

**Prerequisites:** Story 3.3

**Technical Notes:**
- Track screen share state in roomStore
- Listen for remote screen share track published/unpublished
- Disable button via disabled prop, not removing
- Update sharer info from participant metadata

---

### Story 3.5: Implement Screen Share Quality Optimization

**As a** viewer,
**I want** the shared screen to display at appropriate quality,
**So that** I can read text and see details clearly.

**Acceptance Criteria:**

**Given** someone is sharing their screen
**When** I view the shared content
**Then** the quality is optimized for content visibility:
  - Text is readable (not blurry from over-compression)
  - UI elements are clearly distinguishable
  - Code in IDEs is legible

**And** quality adapts to network conditions:
  - On good network: high resolution, 30fps minimum
  - On poor network: reduced resolution but maintains readability
  - Never drops below readable threshold for text content

**And** the system prefers quality over framerate for screen content (opposite of camera video)

**Prerequisites:** Story 3.2

**Technical Notes:**
- Configure LiveKit screen share encoding:
  - Resolution: up to 1080p (or source resolution)
  - Framerate: 30fps (can drop to 15fps on poor network)
  - Codec preference: VP9 or AV1 for better text quality
- Use `screenShareSimulcastEncodings` for adaptive quality
- Set `contentHint: 'text'` on video track for encoder optimization

---

### Story 3.6: Create Sharer's Transparent Overlay Window

**As a** screen sharer,
**I want** to see annotations on my actual shared screen (not inside NAMELESS),
**So that** I can see what others are pointing at without switching windows.

**Acceptance Criteria:**

**Given** I start sharing my screen
**When** the screen share is active
**Then** a transparent overlay window is created by Tauri

**And** the overlay window:
  - Is positioned exactly over my shared screen/window
  - Is always-on-top (above shared content, below system UI)
  - Is fully transparent (click-through when not drawing)
  - Has no window decorations (frameless)
  - Matches the exact dimensions of shared content

**And** when sharing a specific window:
  - Overlay tracks the window position if it moves
  - Overlay resizes if window resizes

**And** when I stop sharing:
  - Overlay window is destroyed
  - No visual artifacts remain

**Prerequisites:** Story 3.1

**Technical Notes:**
- Use Tauri window creation with `transparent: true`, `decorations: false`, `alwaysOnTop: true`
- For full screen: position at monitor bounds
- For window: use platform APIs to track target window position
- This overlay will render annotations in Epic 4 (placeholder for now)
- Per Architecture ADR-003: Hybrid rendering approach

**Windows-Specific Validation (High Priority):**

Per Implementation Readiness assessment, Windows transparent overlay behavior needs early validation:

- [ ] Transparent window renders correctly on Windows 10 and Windows 11
- [ ] Click-through (`WS_EX_TRANSPARENT`, `WS_EX_LAYERED`) allows interaction with underlying app
- [ ] Overlay position stays aligned with shared window (no drift)
- [ ] Multi-monitor and high-DPI scaling handled correctly
- [ ] Performance acceptable (no visible lag in overlay rendering)

**Fallback Plan if Windows Transparency Fails:**
- Option A: Small floating preview window showing annotations
- Option B: "Annotations visible to viewers" indicator only on sharer's screen
- Document findings and update ADR-003 with Windows-specific notes

**Recommendation:** Create minimal POC for Windows transparent overlay before full implementation.

---

### Story 3.7: Create Sharer's Floating Control Bar

**As a** screen sharer,
**I want** a floating control bar that stays visible on top of all windows,
**So that** I can access meeting controls (mic, camera, stop sharing, leave) without switching back to the minimized Nameless window.

**Acceptance Criteria:**

**Given** I start sharing my screen
**When** the screen share is active
**Then** a floating control bar window is created by Tauri

**And** the floating control bar:
  - Is always on top of ALL windows and screens (highest z-order)
  - Shows sharing status indicator (red dot + "Sharing" text)
  - Shows mic toggle button (mute/unmute)
  - Shows camera toggle button (enable/disable)
  - Shows participant face circles (Around-style, up to 4 visible, "+N" for overflow)
  - Shows "Stop Share" button (accent color)
  - Shows "Leave" button (destructive style)
  - Has semi-transparent dark background (`rgba(0,0,0,0.85)`)
  - Has rounded corners (12px radius)
  - Has compact height (~48px)

**And** the control bar behavior:
  - Default position: top-center of primary screen
  - Is draggable - can be repositioned anywhere on any screen
  - Position is persisted between sessions
  - Works across all screens/desktops (multi-monitor)
  - Fades to 60% opacity after 5 seconds idle
  - Returns to full opacity on hover

**And** button actions:
  - Mic toggle: mutes/unmutes microphone
  - Camera toggle: enables/disables camera
  - Stop Share: stops sharing, dismisses all native windows, restores main window
  - Leave: shows confirmation, then leaves meeting

**And** when I stop sharing:
  - Floating control bar is destroyed
  - Main Nameless window restores from minimized state

**Prerequisites:** Story 3.1

**Technical Notes:**
- Use Tauri window creation with `alwaysOnTop: true`, `decorations: false`
- macOS: NSWindow with `level: .floating`, `collectionBehavior: .canJoinAllSpaces`
- Windows: `WS_EX_TOPMOST` window style
- Render React component inside the floating window
- Store position in settingsStore with localStorage persistence
- Communicate with main window via Tauri events for button actions

**FRs Addressed:** FR21, FR23, FR24, FR25, FR26

---

### Story 3.8: Create Share Border Indicator

**As a** screen sharer,
**I want** a visual border around my shared content,
**So that** I can clearly see what is being captured and shared with others.

**Acceptance Criteria:**

**Given** I start sharing my screen
**When** the screen share is active
**Then** a visible border appears around the shared content

**And** the border indicator:
  - Is a thin colored border (3-4px, accent color or red)
  - Exactly frames the shared window/screen boundaries
  - Is always visible while sharing (doesn't fade)
  - Is click-through (doesn't intercept mouse events)
  - Has no fill (transparent interior)

**And** when sharing a specific window:
  - Border tracks the window position if it moves
  - Border resizes if window resizes

**And** when sharing a full screen:
  - Border appears at screen edges

**And** when I stop sharing:
  - Border indicator is destroyed
  - No visual artifacts remain

**Prerequisites:** Story 3.1

**Technical Notes:**
- Use Tauri transparent window with only border rendering
- Position using platform APIs to track shared window bounds
- Use `transparent: true`, `decorations: false`, `alwaysOnTop: true`
- z-order: below floating control bar, above annotation overlay
- macOS: May need to handle fullscreen apps specially
- Windows: Use `WS_EX_TRANSPARENT` + `WS_EX_LAYERED` for click-through

**FRs Addressed:** FR22

---

### Story 3.9: Implement Main Window Auto-Minimize and Restore

**As a** screen sharer,
**I want** the Nameless window to automatically minimize when I start sharing,
**So that** my shared content is visible and I can focus on presenting.

**Acceptance Criteria:**

**Given** I'm in a meeting and initiate screen share
**When** I select a window/screen to share
**Then** the main Nameless window automatically minimizes

**And** the shared window/screen is brought to focus (foreground)
**And** the floating control bar, share border, and annotation overlay appear

**And** when I stop sharing (via floating bar "Stop Share"):
  - Main Nameless window restores from minimized state
  - Window returns to its previous position and size
  - All native windows (floating bar, border, overlay) are dismissed

**And** when I click "Leave" on floating bar:
  - Confirmation dialog appears (if host)
  - On confirm, all native windows dismissed
  - Main window restores briefly, then closes/returns to home

**And** if the screen share is stopped by the OS (e.g., user clicks system stop):
  - App detects track ended event
  - All native windows dismissed
  - Main window restores

**Prerequisites:** Story 3.1, 3.7, 3.8

**Technical Notes:**
- Use Tauri window API: `window.minimize()`, `window.unminimize()`
- Store window position/size before minimizing for exact restore
- Focus shared window using platform-specific APIs:
  - macOS: `NSApp.activate(ignoringOtherApps:)`
  - Windows: `SetForegroundWindow`
- Listen to LiveKit track ended event for system-initiated stops
- Coordinate with floating control bar button actions via Tauri events

**FRs Addressed:** FR21

---

## Epic 4: Real-Time Annotations

**Goal:** Enable users to draw on shared screens in real-time with sub-200ms latency - THE CORE VALUE PROPOSITION of NAMELESS. This is the "pointing finger" moment.

**User Value:** After this epic, users can draw circles, highlight areas, and point at things on shared screens - and everyone sees it instantly!

**FRs Addressed:** FR21, FR22, FR23, FR24, FR27, FR28, FR29, FR30

---

### Story 4.1: Create Annotation Canvas Component for Viewers

**As a** viewer,
**I want** to see an annotation layer overlaid on the shared screen,
**So that** I can see what others are drawing in real-time.

**Acceptance Criteria:**

**Given** someone is sharing their screen
**When** the screen share is displayed
**Then** a transparent canvas overlay is rendered on top of the video element

**And** the canvas:
  - Matches the exact dimensions of the video element
  - Has `pointer-events: none` by default (click-through)
  - Uses HTML Canvas 2D for rendering
  - Clears and redraws on each animation frame when strokes change

**And** the canvas scales correctly:
  - If video is letterboxed, canvas only covers the video content area
  - Annotations stay aligned with video content when window resizes

**And** the canvas is not visible when no screen is being shared

**Prerequisites:** Story 3.2

**Technical Notes:**
- Create AnnotationCanvas component in `client/src/components/AnnotationCanvas/`
- Use `requestAnimationFrame` for 60fps render loop
- Canvas context: `2d` with `willReadFrequently: false` for performance
- Implement coordinate transform from normalized [0,1] to canvas pixels
- Store canvas ref for imperative drawing operations

---

### Story 4.2: Implement Annotation Store with Zustand

**As a** developer,
**I want** a centralized store for annotation state,
**So that** strokes can be managed consistently across the application.

**Acceptance Criteria:**

**Given** the annotation system is initialized
**When** strokes are added, updated, or removed
**Then** the store updates and triggers re-renders

**And** the store provides:
```typescript
interface AnnotationState {
  strokes: Stroke[];
  activeStroke: Stroke | null;  // Currently being drawn
  activeTool: 'pen' | 'highlighter' | 'eraser';

  // Actions
  addStroke: (stroke: Stroke) => void;
  updateStroke: (strokeId: string, points: Point[]) => void;
  completeStroke: (strokeId: string) => void;
  deleteStroke: (strokeId: string) => void;
  clearAll: () => void;
  setActiveTool: (tool: Tool) => void;
  setActiveStroke: (stroke: Stroke | null) => void;
}
```

**And** the store is optimized for frequent updates (batched renders)
**And** strokes are stored with normalized coordinates [0,1]

**Prerequisites:** Story 1.3

**Technical Notes:**
- Location: `client/src/stores/annotationStore.ts`
- Use Zustand with subscriptions for selective re-renders
- Implement `immer` middleware if mutation patterns are complex
- Add unit tests for all store actions

---

### Story 4.3: Implement Local Stroke Drawing (Pen Tool)

**As an** annotator,
**I want** to draw freehand strokes on the shared screen,
**So that** I can point at and mark up content visually.

**Acceptance Criteria:**

**Given** someone is sharing their screen and I have annotator permissions
**When** I press and drag on the canvas
**Then** a stroke appears immediately under my cursor (< 16ms local render)

**And** the stroke:
  - Uses my assigned participant color
  - Has smooth, anti-aliased lines
  - Follows my cursor precisely
  - Uses Perfect Freehand library for natural brush feel

**And** drawing interaction:
  - Mouse down: start new stroke
  - Mouse move: extend stroke with new points
  - Mouse up: finalize stroke

**And** the pen tool is active by default (key `2`)
**And** cursor changes to crosshair when over annotation area

**Prerequisites:** Story 4.1, 4.2, 3.2

**Technical Notes:**
- Use `perfect-freehand` library for stroke path generation
- Capture points at 60fps during drag
- Store points in normalized [0,1] coordinates
- Convert to canvas coordinates only during render
- Implement in AnnotationCanvas with pointer event handlers

---

### Story 4.4: Implement Highlighter Tool

**As an** annotator,
**I want** to use a highlighter tool for semi-transparent emphasis,
**So that** I can highlight areas without fully obscuring content.

**Acceptance Criteria:**

**Given** I select the highlighter tool (key `3`)
**When** I draw on the canvas
**Then** the stroke appears with semi-transparent fill

**And** the highlighter stroke:
  - Has 40% opacity (allows content to show through)
  - Is wider than pen strokes (3x width)
  - Uses my participant color with alpha
  - Has flat/square ends (not rounded like pen)

**And** the toolbar shows highlighter as active when selected
**And** cursor indicates highlighter mode

**Prerequisites:** Story 4.3

**Technical Notes:**
- Store tool type in stroke metadata: `tool: 'highlighter'`
- Render with `globalAlpha = 0.4` on canvas context
- Use wider stroke width in Perfect Freehand options
- Different `thinning` and `smoothing` params for highlighter feel

---

### Story 4.5: Implement Eraser Tool

**As an** annotator,
**I want** to erase my own strokes,
**So that** I can correct mistakes or clean up my annotations.

**Acceptance Criteria:**

**Given** I select the eraser tool (key `7`)
**When** I click on or drag over my own strokes
**Then** those strokes are deleted

**And** eraser behavior:
  - Only erases strokes I created (my participantId)
  - Erases entire stroke on touch (not partial erase)
  - Works by hit-testing stroke bounding boxes
  - Visual feedback: stroke highlights before deletion

**And** I cannot erase other participants' strokes (unless I'm host/sharer - covered in Epic 5)
**And** cursor changes to eraser icon when tool selected

**Prerequisites:** Story 4.3

**Technical Notes:**
- Implement hit-testing using stroke bounding box + point distance
- Compare stroke.participantId with local user ID
- Delete via annotationStore.deleteStroke()
- Send delete message via DataTrack after local delete

---

### Story 4.6: Build Annotation Toolbar Component

**As an** annotator,
**I want** a toolbar to switch between annotation tools,
**So that** I can quickly access pen, highlighter, and eraser.

**Acceptance Criteria:**

**Given** someone is sharing their screen
**When** I look at the top of the canvas area
**Then** I see the annotation toolbar with tools:

```
[↖️ Select][✏️ Pen][🖍️ Highlighter][🧹 Eraser] | [🗑️ Clear All]
    1/V       2          3              7             0
```

**And** toolbar behavior:
  - Active tool has filled accent background
  - Hover shows tooltip with tool name and shortcut
  - Keyboard shortcuts work: 1/V, 2, 3, 7, 0
  - Clear All (0) only visible/enabled for host (grayed otherwise)

**And** toolbar styling per UX spec:
  - Horizontal layout, subtle rounded buttons
  - Shortcut numbers shown below icons (small, muted)
  - Separator before destructive action

**And** toolbar is disabled (50% opacity) when no screen share active

**Prerequisites:** Story 4.3, 4.4, 4.5

**Technical Notes:**
- Create AnnotationToolbar component per UX spec Section 6
- Use shadcn/ui Button with custom styling
- Lucide icons for tool icons
- Connect to annotationStore for active tool state
- Register keyboard shortcuts globally

---

### Story 4.7: Implement DataTrack Annotation Sync

**As a** participant,
**I want** to see others' annotations in real-time,
**So that** we can collaborate visually during the meeting.

**Acceptance Criteria:**

**Given** I draw a stroke on the canvas
**When** I'm drawing (mouse down → move → up)
**Then** other participants see my stroke appear in real-time

**And** sync behavior:
  - Incremental updates every 16ms during drawing (batched points)
  - Final stroke sent on mouse up (complete point array)
  - Latency < 200ms end-to-end (local draw to remote display)

**And** message types per Architecture spec:
  - `stroke_update`: incremental points during drawing
  - `stroke_complete`: final stroke with all points
  - `stroke_delete`: when erasing
  - `clear_all`: when host clears

**And** messages are sent via LiveKit DataTrack (reliable mode)
**And** local strokes render immediately (optimistic UI)

**Prerequisites:** Story 4.3, 2.6

**Technical Notes:**
- Use `room.localParticipant.publishData()` for sending
- Listen to `RoomEvent.DataReceived` for receiving
- Message format per Architecture "Message Protocol" section
- Batch point updates at 60fps intervals (collect points, send batch)
- Use reliable DataTrack for strokes (ordered delivery)

---

### Story 4.8: Implement Late-Joiner Annotation Sync

**As a** late-joining participant,
**I want** to see all existing annotations when I join,
**So that** I have full context of what's been discussed.

**Acceptance Criteria:**

**Given** annotations exist on the shared screen
**When** I join the meeting mid-session
**Then** I see all existing annotations immediately (< 1 second)

**And** sync flow:
  1. I join and connect to LiveKit
  2. I send `state_request` message via DataTrack
  3. Host (or any participant with full state) responds with `state_snapshot`
  4. I reconstruct canvas from snapshot
  5. I start receiving live updates

**And** the canvas shows loading indicator while waiting for snapshot
**And** if no response within 3 seconds, retry request
**And** snapshot includes all completed strokes (not in-progress ones)

**Prerequisites:** Story 4.7

**Technical Notes:**
- Message types: `state_request`, `state_snapshot` per Architecture
- Host is primary responder, but any participant can respond
- Snapshot: array of all Stroke objects from annotationStore
- Timestamp on snapshot for conflict resolution
- Handle case where no one has state (empty response)

---

### Story 4.9: Implement Resolution-Independent Coordinates

**As a** participant on any display,
**I want** annotations to appear in the correct position regardless of my screen resolution,
**So that** everyone sees annotations in the same location.

**Acceptance Criteria:**

**Given** participants have different screen sizes and resolutions
**When** someone draws a circle around a button
**Then** all participants see the circle around the same button

**And** coordinate system:
  - All coordinates stored as normalized [0, 1] range
  - (0, 0) = top-left of shared content
  - (1, 1) = bottom-right of shared content
  - Transform to/from pixel coordinates at render time

**And** on window resize:
  - Annotations scale proportionally with video
  - No position drift or misalignment
  - Smooth scaling without flicker

**And** annotations align on both viewer canvas AND sharer overlay

**Prerequisites:** Story 4.3

**Technical Notes:**
- Implement `normalizeCoordinates(pixelX, pixelY, canvasWidth, canvasHeight)` utility
- Implement `denormalizeCoordinates(normX, normY, canvasWidth, canvasHeight)` utility
- Store all points in normalized form in annotationStore
- Convert on input (capture) and output (render)
- Add unit tests for coordinate transformations

---

### Story 4.10: Assign Unique Colors Per Participant

**As a** participant,
**I want** each person's annotations to have a distinct color,
**So that** I can tell who drew what.

**Acceptance Criteria:**

**Given** multiple participants are annotating
**When** strokes are displayed
**Then** each participant's strokes are in their assigned color

**And** color assignment:
  - First participant (host): Orange (#f97316)
  - Second: Cyan (#06b6d4)
  - Third: Purple (#a855f7)
  - Fourth: Green (#22c55e)
  - Fifth: Pink (#ec4899)
  - Cycle back to orange for 6th, etc.

**And** colors are assigned at join time (stored in token metadata)
**And** color is visible in:
  - Annotation strokes
  - Participant list (avatar border)
  - "Drawing" indicator when someone is actively annotating

**And** colors are high-visibility on any screen content (tested on light/dark backgrounds)

**Prerequisites:** Story 4.7, 2.1

**Technical Notes:**
- Color assigned server-side when generating join token
- Stored in participant metadata: `{ color: '#f97316' }`
- Extract from LiveKit participant object
- Use same colors defined in `@nameless/shared` constants

---

### Story 4.11: Render Annotations on Sharer's Overlay

**As a** screen sharer,
**I want** to see annotations on my actual shared screen,
**So that** I can see what others are pointing at without looking at NAMELESS.

**Acceptance Criteria:**

**Given** I'm sharing my screen and the transparent overlay exists (Story 3.6)
**When** participants draw annotations
**Then** the annotations appear on the overlay window over my shared content

**And** the overlay canvas:
  - Renders the same strokes as viewer canvases
  - Uses same coordinate transformation
  - Updates in real-time (< 200ms from remote draw to local overlay)
  - Is click-through except when I'm drawing

**And** I can also draw on my own shared screen:
  - When I draw, overlay becomes interactive (not click-through)
  - My strokes appear on the overlay and sync to others
  - Release returns to click-through mode

**And** coordinate alignment between:
  - Sharer's overlay (on actual screen content)
  - Viewer's canvas (on video element)
  - Must match perfectly

**Prerequisites:** Story 3.6, 4.7, 4.9

**Technical Notes:**
- Sharer's overlay subscribes to same annotationStore
- Render loop identical to viewer canvas
- Coordinate transform accounts for overlay window position
- Toggle `ignore_cursor_events` Tauri option for click-through
- Communication between main window and overlay via Tauri events

---

## Epic 5: Permissions & Moderation

**Goal:** Enable hosts to manage meetings professionally - control who can annotate, remove troublemakers, and maintain order in the collaboration space.

**User Value:** After this epic, hosts have full control over their meetings with role-based permissions and moderation tools.

**FRs Addressed:** FR5, FR25, FR26, FR31, FR32, FR33, FR34, FR35, FR36, FR37

---

### Story 5.1: Implement Role System Infrastructure

**As a** developer,
**I want** a robust role system that controls participant capabilities,
**So that** permissions can be enforced consistently across the application.

**Acceptance Criteria:**

**Given** participants join with different roles
**When** they attempt various actions
**Then** permissions are enforced based on their role

**And** the role hierarchy is:
| Role | Can Annotate | Can Delete Own | Can Delete Any | Can Clear All | Can Remove Users | Can Change Roles |
|------|--------------|----------------|----------------|---------------|------------------|------------------|
| Host | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| Sharer | ✅ | ✅ | ✅ (own screen) | ❌ | ❌ | ❌ |
| Annotator | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ |
| Viewer | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |

**And** role information is stored in:
  - LiveKit participant metadata (source of truth)
  - Local roomStore (for UI)

**And** helper functions exist:
```typescript
canAnnotate(role: Role): boolean
canDeleteStroke(role: Role, stroke: Stroke, userId: string): boolean
canClearAll(role: Role): boolean
canModerateUsers(role: Role): boolean
```

**Prerequisites:** Story 1.3, 2.6

**Technical Notes:**
- Implement in `@nameless/shared` for use in both client and server
- Role is set at token generation time (server-side)
- Role changes require new token or DataTrack message from host
- Add unit tests for all permission checks

---

### Story 5.2: Display User Role in UI

**As a** user,
**I want** to see my current role and other participants' roles,
**So that** I understand what actions I can take.

**Acceptance Criteria:**

**Given** I'm in a meeting
**When** I look at the participant list
**Then** each participant shows their role as a badge:
  - Host: Crown icon + "Host" badge
  - Sharer: Screen icon + "Sharing" badge (when actively sharing)
  - Annotator: Pen icon (subtle, default role)
  - Viewer: Eye icon + "View only" badge

**And** my own role is prominently displayed:
  - In the sidebar header: "You (Host)" or "You (Viewer)"
  - Clear indication if I cannot annotate: "View only mode"

**And** role badges use appropriate colors:
  - Host: Accent color (`--accent`)
  - Sharer: Info color (`--info`)
  - Viewer: Muted color (`--text-muted`)
  - Annotator: No special color (default)

**Prerequisites:** Story 2.5, 5.1

**Technical Notes:**
- Update ParticipantListItem component
- Add role badge component with icon + text
- Dynamic badge for sharer (appears when sharing starts)
- Tooltip on badge shows full role description

---

### Story 5.3: Enforce Annotation Permissions

**As a** viewer,
**I want** to be prevented from annotating,
**So that** the meeting host maintains control over who can draw.

**Acceptance Criteria:**

**Given** I have the "viewer" role
**When** I try to draw on the canvas
**Then** nothing happens (no stroke appears)

**And** the UI indicates I cannot annotate:
  - Toolbar is hidden or disabled
  - Cursor remains default (not crosshair)
  - Hovering over canvas shows tooltip: "You don't have permission to annotate"

**And** if my role changes from viewer to annotator mid-meeting:
  - Toolbar becomes enabled
  - I can now draw
  - Toast notification: "You can now annotate"

**And** keyboard shortcuts for tools are disabled for viewers

**Prerequisites:** Story 5.1, 4.3

**Technical Notes:**
- Check `canAnnotate(role)` before enabling drawing
- Disable pointer events on canvas for viewers
- Listen for role change in participant metadata
- Role changes broadcast via DataTrack from host

---

### Story 5.4: Implement Host Clear All Annotations

**As a** host,
**I want** to clear all annotations from the screen,
**So that** I can reset the canvas for a fresh discussion.

**Acceptance Criteria:**

**Given** I'm the host and there are annotations on screen
**When** I click "Clear All" (key `0`)
**Then** a confirmation toast appears: "Clear all annotations?" with Undo option

**And** after confirmation (or 3 seconds):
  - All annotations are removed from canvas
  - All participants see annotations cleared
  - Toast: "All annotations cleared"

**And** if I click "Undo" within 5 seconds:
  - Annotations are restored
  - Other participants see restoration

**And** the Clear All button is:
  - Visible and enabled for hosts
  - Hidden for non-hosts (not just disabled)

**Prerequisites:** Story 5.1, 4.7

**Technical Notes:**
- Send `clear_all` message via DataTrack
- Store cleared strokes temporarily for undo
- Undo only available for the host who cleared
- After undo window expires, strokes are permanently removed

---

### Story 5.5: Implement Sharer Delete Any Annotation

**As a** screen sharer,
**I want** to delete any annotation on my shared screen,
**So that** I can remove distracting or inappropriate drawings.

**Acceptance Criteria:**

**Given** I'm sharing my screen
**When** I use the eraser tool (key `7`)
**Then** I can erase ANY stroke, not just my own

**And** visual feedback:
  - Hovering over any stroke shows it can be deleted
  - Stroke highlights on hover (outline glow)
  - Tooltip: "Click to remove" or "Your annotation" (if mine)

**And** when I delete someone else's stroke:
  - It's removed for all participants
  - No notification to the original author (to avoid interruption)

**And** when I stop sharing:
  - I lose the ability to delete others' strokes
  - Can only delete my own again

**Prerequisites:** Story 5.1, 4.5

**Technical Notes:**
- Check `canDeleteStroke(role, stroke, userId)` in eraser handler
- Sharer role is dynamic (set when sharing starts)
- Update role in participant metadata when sharing starts/stops
- Send `stroke_delete` message with authorization

---

### Story 5.6: Implement Host Role Assignment

**As a** host,
**I want** to change other participants' roles,
**So that** I can promote helpers or restrict disruptive users.

**Acceptance Criteria:**

**Given** I'm the host
**When** I click on a participant in the sidebar
**Then** I see a context menu with role options:
  - "Make Annotator" (if currently viewer)
  - "Make Viewer" (if currently annotator)
  - "Make Host" (transfer host role)

**And** selecting a role:
  - Updates the participant's role immediately
  - Shows toast: "{name} is now an Annotator"
  - Participant sees notification of their role change

**And** when transferring host role:
  - Confirmation dialog: "Transfer host to {name}? You will become an Annotator."
  - After transfer, I become Annotator, they become Host
  - Only one host at a time

**And** the context menu shows:
  - Current role checkmark
  - "Remove from meeting" option (red/destructive)

**Prerequisites:** Story 5.1, 5.2

**Technical Notes:**
- Send `role_change` message via DataTrack
- Server validates role changes (only host can change)
- Update participant metadata in LiveKit
- New participant tokens reflect current role

---

### Story 5.7: Implement Remove Participant

**As a** host,
**I want** to remove disruptive participants from the meeting,
**So that** I can maintain a productive environment.

**Acceptance Criteria:**

**Given** I'm the host
**When** I click "Remove from meeting" on a participant
**Then** I see confirmation: "Remove {name} from meeting?"

**And** after confirmation:
  - Participant is disconnected immediately
  - They see message: "You have been removed from this meeting"
  - They cannot rejoin with same token (token invalidated)
  - Other participants see toast: "{name} was removed"

**And** the removed participant:
  - Returns to home screen
  - Can request new join link from host (out of band)

**And** I cannot remove myself (option not shown)

**Prerequisites:** Story 5.6, 2.12

**Technical Notes:**
- Send `participant_remove` message via DataTrack
- Server invalidates their token
- Force disconnect via LiveKit admin API or DataTrack command
- Removed participant's strokes remain (host can clear if needed)

---

### Story 5.8: Implement Room-Wide Annotation Toggle

**As a** host,
**I want** to disable annotations for the entire room,
**So that** I can present without interruption.

**Acceptance Criteria:**

**Given** I'm the host
**When** I toggle "Disable Annotations" in room settings
**Then** all participants (except me) lose annotation ability

**And** the UI updates for all:
  - Toolbar shows "Annotations disabled by host"
  - Canvas becomes view-only
  - Existing annotations remain visible

**And** when I re-enable annotations:
  - All annotators can draw again
  - Viewers remain viewers
  - Toast: "Annotations enabled"

**And** the toggle is accessible from:
  - Room settings menu
  - Quick action in toolbar area (for host)

**Prerequisites:** Story 5.1, 5.3

**Technical Notes:**
- Add `annotationsEnabled` boolean to room state
- Send `room_settings` message via DataTrack
- Check this flag in addition to role permissions
- Host can always annotate (even when disabled for others)

---

## Epic 6: Connection Resilience

**Goal:** Make meetings robust against network issues - automatic reconnection, state preservation, and graceful degradation so users stay productive even on unstable connections.

**User Value:** After this epic, meetings survive network blips, annotation state is preserved, and users get clear feedback about connection status.

**FRs Addressed:** FR42, FR43, FR44, FR45, FR46

---

### Story 6.1: Implement Connection State Management

**As a** developer,
**I want** a centralized connection state system,
**So that** the application can respond appropriately to network changes.

**Acceptance Criteria:**

**Given** the application is running
**When** network conditions change
**Then** connection state is tracked and exposed to the UI

**And** connection states include:
```typescript
type ConnectionState =
  | 'connecting'     // Initial connection in progress
  | 'connected'      // Fully connected and operational
  | 'reconnecting'   // Lost connection, attempting to restore
  | 'disconnected'   // Connection lost, not attempting reconnect
  | 'failed';        // Reconnection attempts exhausted
```

**And** the state includes metadata:
```typescript
interface ConnectionInfo {
  state: ConnectionState;
  latency: number | null;        // RTT in ms when connected
  reconnectAttempt: number;      // Current attempt count
  lastConnected: number | null;  // Timestamp of last successful connection
}
```

**And** state changes trigger events/subscriptions for UI updates

**Prerequisites:** Story 2.6

**Technical Notes:**
- Extend roomStore with connection state
- Listen to LiveKit Room connection events
- Measure latency via periodic ping (DataTrack round-trip)
- Expose via useConnectionState() hook

---

### Story 6.2: Display Connection Status Indicator

**As a** user,
**I want** to see my connection status clearly,
**So that** I know if there are network issues affecting my meeting.

**Acceptance Criteria:**

**Given** I'm in a meeting
**When** I look at the toolbar area
**Then** I see a connection status indicator

**And** the indicator shows per UX spec:
| State | Appearance |
|-------|------------|
| Connected | Green dot + "Connected" (can show latency: "23ms") |
| Reconnecting | Amber dot (animated) + "Reconnecting..." |
| Disconnected | Red dot + "Disconnected" + Retry button |

**And** in Focus Mode:
  - Only the colored dot shows (minimal)
  - Full text appears on hover

**And** clicking the indicator shows connection details:
  - Current latency
  - Connection duration
  - Network quality estimate

**Prerequisites:** Story 6.1, 2.5

**Technical Notes:**
- Implement ConnectionStatus component per UX spec Section 6
- Use `aria-live="polite"` for screen reader announcements
- Pulse animation on reconnecting state (respects prefers-reduced-motion)
- Position: top-right of toolbar area

---

### Story 6.3: Implement Automatic Reconnection

**As a** user,
**I want** to automatically reconnect after brief network interruptions,
**So that** I don't have to manually rejoin after a WiFi blip.

**Acceptance Criteria:**

**Given** I'm in a meeting and my network drops briefly
**When** the connection is lost
**Then** the application automatically attempts to reconnect

**And** reconnection behavior:
  - First retry: immediate
  - Subsequent retries: exponential backoff (1s, 2s, 4s, 8s, 16s max)
  - Maximum attempts: 10 (then stops and shows manual retry)
  - Status updates shown during each attempt

**And** on successful reconnection:
  - Toast: "Reconnected"
  - Resume receiving updates from room
  - Re-sync annotation state (if needed)

**And** during reconnection:
  - UI remains functional (can view cached state)
  - Drawing is disabled (queued locally if attempted)
  - Other participants see me as "reconnecting"

**Prerequisites:** Story 6.1, 6.2

**Technical Notes:**
- LiveKit handles most reconnection logic
- Configure `Room.connect()` with reconnect options
- Listen to `RoomEvent.Reconnecting`, `RoomEvent.Reconnected`
- Extend with custom retry logic if LiveKit's is insufficient

---

### Story 6.4: Preserve Annotation State During Reconnection

**As a** user,
**I want** my annotation state preserved during network issues,
**So that** I don't lose context when reconnection completes.

**Acceptance Criteria:**

**Given** I was viewing annotations before disconnect
**When** I reconnect to the meeting
**Then** I see the current annotation state (not stale state)

**And** state preservation behavior:
  - Local strokes from before disconnect are retained
  - On reconnect, request state sync from peers
  - Merge received state with local state
  - Resolve conflicts (remote wins for remote strokes, local wins for own strokes)

**And** if I was mid-stroke when disconnected:
  - Incomplete stroke is discarded
  - No phantom strokes appear for others

**And** strokes drawn by others during my disconnect:
  - Are received via state sync
  - Appear immediately on my canvas

**Prerequisites:** Story 6.3, 4.8

**Technical Notes:**
- Reuse late-joiner sync mechanism (state_request/state_snapshot)
- Add timestamp to strokes for conflict resolution
- Queue any local actions during disconnect, replay on reconnect
- Clear in-progress stroke on disconnect

---

### Story 6.5: Queue Local Actions During Offline

**As a** user,
**I want** my actions queued when offline,
**So that** they're applied when I reconnect (if still valid).

**Acceptance Criteria:**

**Given** I'm disconnected but UI is still showing
**When** I attempt to draw or interact
**Then** actions are queued locally

**And** queue behavior:
  - Drawing attempts: queued with timestamp
  - Tool changes: applied locally, no queue needed
  - Eraser actions: queued (may fail if stroke deleted by others)

**And** on reconnect:
  - Sync state first
  - Replay queued strokes (if screen share still active)
  - Discard queued actions if context changed (e.g., screen share ended)
  - Show toast if actions were discarded: "Some actions couldn't be applied"

**And** visual feedback during offline:
  - Drawing still works locally (optimistic)
  - Strokes appear with "pending" indicator (subtle)
  - Clear feedback that sync will happen on reconnect

**Prerequisites:** Story 6.4

**Technical Notes:**
- Create action queue in annotationStore
- Queue structure: `{ type, payload, timestamp, localStrokeId }`
- Max queue size: 100 actions (prevent memory issues)
- Replay queue in order after state sync

---

### Story 6.6: Implement Graceful Degradation

**As a** user,
**I want** the meeting to remain usable during poor network conditions,
**So that** I can continue participating even with limited connectivity.

**Acceptance Criteria:**

**Given** network quality degrades (high latency, packet loss)
**When** connection becomes unstable
**Then** the application adapts gracefully

**And** degradation levels:

| Quality | Latency | Behavior |
|---------|---------|----------|
| Good | < 100ms | Full functionality |
| Fair | 100-300ms | Reduce video quality, show warning |
| Poor | 300-1000ms | Pause video, audio-only, annotation continues |
| Critical | > 1000ms | Show "unstable connection" warning, queue actions |

**And** quality indicator:
  - Subtle icon change on connection indicator
  - Tooltip shows current quality level
  - No disruptive alerts for temporary dips

**And** automatic recovery:
  - Quality improves → restore full functionality
  - No manual intervention needed

**Prerequisites:** Story 6.2, 6.3

**Technical Notes:**
- Use LiveKit's connection quality events
- Implement quality estimation via latency + packet loss
- Configure adaptive bitrate in LiveKit room options
- Debounce quality changes (don't flicker)

---

### Story 6.7: Handle Disconnection Notifications

**As a** user,
**I want** clear notifications about connection events,
**So that** I understand what's happening with my meeting.

**Acceptance Criteria:**

**Given** connection events occur
**When** the event happens
**Then** appropriate notification is shown

**And** notification types:
| Event | Notification |
|-------|--------------|
| Connection lost | Toast (warning): "Connection lost. Reconnecting..." |
| Reconnect success | Toast (success): "Reconnected" |
| Reconnect failed | Modal: "Unable to reconnect. [Retry] [Leave]" |
| Peer disconnect | Toast (info): "{name} disconnected" |
| Peer reconnect | Toast (info): "{name} reconnected" |

**And** notification behavior:
  - Don't spam notifications for rapid connect/disconnect
  - Debounce peer status changes (2 second window)
  - Critical notifications (failed) require user action

**And** audio feedback:
  - Subtle chime on reconnect success (respects system sound settings)
  - No sound on warning/errors (not alarming)

**Prerequisites:** Story 6.2, 6.3

**Technical Notes:**
- Use toast system from UX spec
- Modal for critical failures (can't auto-dismiss)
- Track peer connection state in roomStore
- Debounce notifications with timestamps

---

## Epic 7: Self-Hosting & Deployment

**Goal:** Enable teams to deploy and run their own NAMELESS instance with minimal friction - Docker Compose deployment, clear documentation, and production-ready configuration.

**User Value:** After this epic, a developer can self-host NAMELESS and run a meeting within 30 minutes (per MVP success criteria).

**FRs Addressed:** FR51, FR52, FR53, FR54, FR55, FR56

---

### Story 7.1: Create Docker Compose Deployment Configuration

**As a** system administrator,
**I want** to deploy NAMELESS with Docker Compose,
**So that** I can run the platform on my own infrastructure with minimal setup.

**Acceptance Criteria:**

**Given** a server with Docker and Docker Compose installed
**When** I run `docker compose up -d`
**Then** NAMELESS is running and accessible

**And** the Docker Compose file includes:
```yaml
services:
  nameless-server:    # Hono API server
  livekit:            # LiveKit SFU
  redis:              # LiveKit state (if needed)
```

**And** configuration is done via `.env` file:
```
# Required
LIVEKIT_API_KEY=your-api-key
LIVEKIT_API_SECRET=your-api-secret

# Optional (with sensible defaults)
SERVER_PORT=3000
LIVEKIT_URL=ws://livekit:7880
PUBLIC_URL=https://your-domain.com
```

**And** the setup process:
  1. Clone repository
  2. Copy `.env.example` to `.env`
  3. Edit `.env` with secrets
  4. Run `docker compose up -d`
  5. Access at `http://localhost:3000`

**And** containers restart automatically on failure

**Prerequisites:** Story 1.2

**Technical Notes:**
- Create `docker-compose.yml` in repository root
- Create `docker-compose.prod.yml` for production overrides
- Use official LiveKit Docker image
- Server Dockerfile: multi-stage build for small image
- Include health checks for all services

---

### Story 7.2: Create Server Dockerfile with Multi-Stage Build

**As a** developer,
**I want** an optimized Docker image for the NAMELESS server,
**So that** deployments are fast and efficient.

**Acceptance Criteria:**

**Given** the server codebase
**When** I build the Docker image
**Then** I get a minimal, production-ready image

**And** the Dockerfile uses multi-stage build:
  - Stage 1: Build (Node.js + TypeScript compilation)
  - Stage 2: Production (Node.js runtime only)

**And** the final image:
  - Is based on `node:20-alpine` (small base)
  - Is < 200MB in size
  - Contains only production dependencies
  - Runs as non-root user
  - Exposes port 3000

**And** the build process:
```bash
docker build -t nameless-server:latest ./packages/server
```

**Prerequisites:** Story 1.2

**Technical Notes:**
- Dockerfile location: `packages/server/Dockerfile`
- Use `.dockerignore` to exclude unnecessary files
- Copy only `dist/` and `node_modules/` to final stage
- Set `NODE_ENV=production`
- Use `tini` as init process for proper signal handling

---

### Story 7.3: Implement Health Check Endpoints

**As a** system administrator,
**I want** health check endpoints for monitoring,
**So that** I can verify the system is running correctly.

**Acceptance Criteria:**

**Given** the server is running
**When** I call the health endpoints
**Then** I receive status information

**And** endpoints provided:

**`GET /api/health`** - Basic health check:
```json
{
  "status": "ok",
  "timestamp": 1732968000000,
  "version": "1.0.0"
}
```

**`GET /api/health/ready`** - Readiness check (all dependencies up):
```json
{
  "status": "ready",
  "checks": {
    "livekit": "connected",
    "server": "ok"
  }
}
```
Returns 503 if any check fails.

**`GET /api/health/live`** - Liveness check (is process alive):
```json
{
  "status": "alive"
}
```

**And** health checks are used by:
  - Docker Compose health check
  - Kubernetes probes (if used)
  - External monitoring systems

**Prerequisites:** Story 1.2

**Technical Notes:**
- Implement in `packages/server/src/routes/health.ts`
- Check LiveKit connectivity via SDK
- Version from `package.json`
- Response time should be < 100ms

---

### Story 7.4: Write Self-Hosting Documentation

**As a** developer wanting to self-host,
**I want** clear documentation to guide me through deployment,
**So that** I can set up NAMELESS without external support.

**Acceptance Criteria:**

**Given** I want to deploy NAMELESS
**When** I read the documentation
**Then** I have all information needed to succeed

**And** documentation includes:

**`README.md`** (repository root):
  - Project overview and features
  - Quick start (3-step deployment)
  - Link to full documentation
  - Screenshots/demo

**`docs/self-hosting.md`**:
  - Prerequisites (Docker, ports, resources)
  - Step-by-step deployment guide
  - Configuration options (all env vars)
  - Reverse proxy setup (nginx, Caddy examples)
  - SSL/TLS configuration
  - Troubleshooting common issues

**`docs/architecture.md`**:
  - System components overview
  - Network diagram
  - Port requirements
  - Data flow explanation

**And** documentation is:
  - Written for developers (technical but clear)
  - Tested by following steps on fresh system
  - Includes copy-pasteable commands

**Prerequisites:** Story 7.1, 7.3

**Technical Notes:**
- Use GitHub-flavored markdown
- Include diagrams (Mermaid for architecture)
- Provide configuration examples, not just descriptions
- Add FAQ section based on anticipated questions

---

### Story 7.5: Implement Update Notification System

**As a** user,
**I want** to be notified when updates are available,
**So that** I can keep my application current.

**Acceptance Criteria:**

**Given** I'm running the NAMELESS desktop app
**When** a new version is available
**Then** I see a notification about the update

**And** the notification shows:
  - "Update available: v1.1.0"
  - "What's new" link (changelog)
  - "Download" button (links to releases page)
  - "Remind me later" option

**And** notification behavior:
  - Check for updates on app launch (after 5 second delay)
  - Check daily while app is running
  - Don't interrupt meetings (show in home screen only)
  - Respect "remind me later" for 24 hours

**And** update check:
  - Compares local version with GitHub releases API
  - Works for self-hosted instances (configurable update URL)
  - Fails gracefully if offline (no error shown)

**Prerequisites:** Story 2.3

**Technical Notes:**
- Use GitHub releases API: `https://api.github.com/repos/org/nameless/releases/latest`
- Store dismissed version in settings
- Tauri can handle auto-update, but start with notification only
- Version comparison: semver

---

### Story 7.6: Implement Recent Rooms History

**As a** user,
**I want** to access my recent rooms from the application,
**So that** I can quickly rejoin rooms I've used before.

**Acceptance Criteria:**

**Given** I've joined rooms in the past
**When** I open the NAMELESS app
**Then** I see my recent rooms on the home screen

**And** recent rooms display:
  - Room name/ID
  - Last joined timestamp ("2 hours ago", "Yesterday")
  - Quick "Rejoin" button
  - Remove from history option

**And** behavior:
  - Maximum 10 recent rooms stored
  - Oldest entries removed when limit reached
  - Rooms that no longer exist show "Room ended" (can't rejoin)
  - History is stored locally only

**And** privacy:
  - Clear history option in settings
  - History not synced anywhere

**Prerequisites:** Story 2.14

**Technical Notes:**
- Store in settingsStore (localStorage)
- Structure: `{ roomId, name, lastJoined, serverUrl }`
- Check room existence before showing "Rejoin" as active
- Add to history on successful join, update on rejoin

---

### Story 7.7: Create Production Build and Release Pipeline

**As a** maintainer,
**I want** an automated build and release pipeline,
**So that** releases are consistent and easy to publish.

**Acceptance Criteria:**

**Given** code is merged to main branch
**When** a release is tagged
**Then** builds are automatically created

**And** the pipeline produces:
  - macOS DMG (Universal: Intel + Apple Silicon)
  - Windows installer (NSIS or MSI)
  - Docker images pushed to registry
  - Server build artifacts

**And** release process:
  1. Create git tag: `git tag v1.0.0`
  2. Push tag: `git push origin v1.0.0`
  3. CI builds all artifacts
  4. Draft GitHub release created with artifacts
  5. Manual review and publish

**And** build artifacts include:
  - Code signing (macOS notarization, Windows signing)
  - Version embedded in app
  - Changelog generated from commits

**Prerequisites:** Story 1.5

**Technical Notes:**
- Use GitHub Actions for CI/CD
- Tauri's GitHub Action for desktop builds
- Docker buildx for multi-arch images
- Store signing certificates in GitHub Secrets
- Use `tauri-action` for cross-platform builds

---

### Story 7.8: Implement LiveKit Integration Configuration

**As a** system administrator,
**I want** to configure NAMELESS to use my LiveKit instance,
**So that** media traffic stays within my infrastructure.

**Acceptance Criteria:**

**Given** I have a self-hosted LiveKit instance
**When** I configure NAMELESS
**Then** all media flows through my LiveKit server

**And** configuration options:
```env
# LiveKit connection
LIVEKIT_URL=wss://livekit.mycompany.com
LIVEKIT_API_KEY=APIxxxxxxxx
LIVEKIT_API_SECRET=xxxxxxxxxxxxxxxx

# Optional: separate WebSocket URL for clients
LIVEKIT_WS_URL=wss://livekit.mycompany.com

# Token settings
TOKEN_EXPIRY_SECONDS=3600
```

**And** the server validates configuration on startup:
  - Tests LiveKit connectivity
  - Logs configuration (without secrets)
  - Fails fast with clear error if LiveKit unreachable

**And** documentation covers:
  - LiveKit self-hosting guide link
  - Recommended LiveKit configuration
  - Firewall/port requirements
  - Load balancing considerations

**Prerequisites:** Story 7.1, 7.4

**Technical Notes:**
- Validate environment variables on server start
- Use LiveKit SDK to test connection
- Log: "Connected to LiveKit at wss://..."
- Error: "Failed to connect to LiveKit: [reason]"

---

### Story 7.9: Implement Auto-Update for Desktop Client

**As a** user,
**I want** the app to automatically update itself,
**So that** I always have the latest features and security fixes without manual intervention.

**Acceptance Criteria:**

**Given** a new version is available
**When** the app checks for updates (on startup and periodically)
**Then** a notification appears indicating an update is available

**And** the update flow:
  1. App checks update server for new version
  2. If update available, shows notification: "Update available (v1.2.0)"
  3. User clicks "Update Now" or "Later"
  4. If "Update Now": downloads update in background with progress
  5. Shows "Restart to complete update" when ready
  6. On restart, new version is active

**And** the update is seamless:
  - Download happens in background (non-blocking)
  - Progress indicator shows download status
  - Update is verified (signature check) before applying
  - Rollback on failure (keep current version)

**And** update settings:
  - Check frequency: configurable (default: on app launch)
  - Auto-download: optional (default: prompt before download)
  - Release channel: stable (future: beta channel)

**And** the update server is configurable for self-hosted:
  - Default: GitHub Releases
  - Self-hosted option: custom update server URL

**Prerequisites:** Story 1.1 (Tauri setup)

**Technical Notes:**
- Use Tauri's built-in updater (`tauri-plugin-updater`)
- Update manifest on GitHub Releases or self-hosted
- Signing key for update verification (code signing)
- Update JSON format:
```json
{
  "version": "1.2.0",
  "notes": "Bug fixes and improvements",
  "pub_date": "2025-01-15T12:00:00Z",
  "platforms": {
    "darwin-aarch64": { "url": "...", "signature": "..." },
    "darwin-x86_64": { "url": "...", "signature": "..." },
    "windows-x86_64": { "url": "...", "signature": "..." }
  }
}
```
- Handle: update in progress, update failed, already latest
- Research validated: auto-update is part of "premium feel"

**FRs Addressed:** FR57 (enhanced from notification to full auto-update)

---

## Summary & Validation

### Epic and Story Totals

| Epic | Stories | Key Deliverables |
|------|---------|------------------|
| Epic 1: Foundation | 5 | Monorepo, Tauri app, Hono server, shared types, testing |
| Epic 2: Basic Meeting | 14 | Room creation/joining, A/V, participant management |
| Epic 3: Screen Sharing | 6 | Screen capture, viewing, quality optimization, overlay |
| Epic 4: Annotations | 11 | Canvas, tools, real-time sync, late-joiner sync |
| Epic 5: Permissions | 8 | Role system, moderation, clear all, room controls |
| Epic 6: Connection Resilience | 7 | Reconnection, state preservation, graceful degradation |
| Epic 7: Self-Hosting | 8 | Docker deployment, documentation, release pipeline |
| **TOTAL** | **59** | |

### FR Coverage Validation

All 56 Functional Requirements from the PRD are covered:

| Category | FRs | Covered By |
|----------|-----|------------|
| Meeting & Room Management | FR1-7 | Epic 2 (FR1-4, FR6-7), Epic 5 (FR5) |
| Audio & Video | FR8-14 | Epic 2 |
| Screen Sharing | FR15-20 | Epic 3 |
| Annotation System | FR21-30 | Epic 4 (FR21-24, FR27-30), Epic 5 (FR25-26) |
| Permission & Roles | FR31-37 | Epic 5 |
| Authentication & Access | FR38-41 | Epic 2 |
| Connection & State | FR42-46 | Epic 6 |
| Desktop Application | FR47-52 | Epic 2 (FR47-50), Epic 7 (FR51-52) |
| Self-Hosting & Deployment | FR53-56 | Epic 7 |

**Coverage: 56/56 FRs (100%)**

### MVP Success Criteria Alignment

From the Product Brief, the MVP success criteria are:

| Criterion | Stories Addressing |
|-----------|-------------------|
| Developer can self-host and run meeting within 30 minutes | 7.1, 7.2, 7.4, 7.8 |
| Screen share with annotation works for 2-10 participants | 3.1-3.5, 4.1-4.11 |
| Annotation latency < 200ms | 4.3, 4.7, 4.9 |
| Late joiners see existing annotations | 4.8 |
| Role permissions work correctly | 5.1-5.8 |
| README and docs enable contributions | 7.4 |

### Dependency Graph (Simplified)

```
Epic 1 (Foundation)
    └── Epic 2 (Basic Meeting)
            ├── Epic 3 (Screen Sharing)
            │       └── Epic 4 (Annotations) ⭐ CORE VALUE
            │               └── Epic 5 (Permissions)
            └── Epic 6 (Connection Resilience)
    └── Epic 7 (Self-Hosting)
```

### Recommended Implementation Order

1. **Epic 1** - Foundation (required first)
2. **Epic 2** - Basic Meeting (video conferencing works)
3. **Epic 3** - Screen Sharing (can share screens)
4. **Epic 4** - Annotations (THE MAGIC MOMENT)
5. **Epic 5** - Permissions (professional meetings)
6. **Epic 6** - Connection Resilience (robust experience)
7. **Epic 7** - Self-Hosting (ready for deployment)

### Notes for Development

- **Parallel Work**: After Epic 1, some stories in Epic 2 can be parallelized (API vs UI)
- **Testing**: Each story includes testable acceptance criteria in BDD format
- **Technical Notes**: Implementation guidance is provided per story
- **Prerequisites**: Story dependencies are explicitly listed
- **UX Alignment**: All UI stories reference UX Design Specification sections

---

## Version History

| Date | Version | Changes | Author |
|------|---------|---------|--------|
| 2025-11-30 | 1.0 | Initial epic and story breakdown | BMad |

---

_This Epic Breakdown was created through the BMad Method create-epics-and-stories workflow, transforming PRD requirements into implementable stories with full traceability._

