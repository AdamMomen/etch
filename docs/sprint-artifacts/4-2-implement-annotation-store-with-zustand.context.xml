<?xml version="1.0" encoding="UTF-8"?>
<!--
  Story Context File: 4-2-implement-annotation-store-with-zustand
  Generated by: BMad Story Context Workflow
  Generated on: 2025-12-18
  
  This file provides comprehensive technical context for implementing
  the annotation store with Zustand state management.
-->
<storyContext version="1.0">
  
  <!-- ==================== METADATA ==================== -->
  <metadata>
    <storyId>4-2</storyId>
    <storyKey>4-2-implement-annotation-store-with-zustand</storyKey>
    <epicId>4</epicId>
    <epicTitle>Real-Time Annotations</epicTitle>
    <contextGeneratedAt>2025-12-18T00:00:00Z</contextGeneratedAt>
    <techStackVersion>
      <zustand>5.0.9</zustand>
      <typescript>5.9.3</typescript>
      <react>19.2.0</react>
      <vitest>2.0.0</vitest>
    </techStackVersion>
  </metadata>

  <!-- ==================== STORY DETAILS ==================== -->
  <story>
    <title>Implement Annotation Store with Zustand</title>
    <userStory>
      As a developer, I need a Zustand store to manage annotation state
      so that strokes can be shared between components and synchronized
      across the application.
    </userStory>
    <status>drafted</status>
    <storyPoints>5</storyPoints>
    <priority>P0 - Critical Path</priority>
  </story>

  <!-- ==================== ACCEPTANCE CRITERIA ==================== -->
  <acceptanceCriteria>
    <criterion id="AC-4.2.1" priority="must">
      Store provides strokes array
      <verification>Test: state shape includes strokes: Stroke[]</verification>
    </criterion>
    <criterion id="AC-4.2.2" priority="must">
      Store provides activeStroke for in-progress drawing
      <verification>Test: state shape includes activeStroke: Stroke | null</verification>
    </criterion>
    <criterion id="AC-4.2.3" priority="must">
      Store provides activeTool state
      <verification>Test: state shape includes activeTool: Tool</verification>
    </criterion>
    <criterion id="AC-4.2.4" priority="must">
      addStroke action adds stroke to array
      <verification>Test: addStroke({...}) results in strokes.length + 1</verification>
    </criterion>
    <criterion id="AC-4.2.5" priority="must">
      updateStroke action appends points to existing stroke
      <verification>Test: updateStroke(id, newPoints) extends stroke.points array</verification>
    </criterion>
    <criterion id="AC-4.2.6" priority="must">
      deleteStroke action removes stroke by id
      <verification>Test: deleteStroke(id) removes stroke from strokes array</verification>
    </criterion>
    <criterion id="AC-4.2.7" priority="must">
      clearAll action empties strokes array
      <verification>Test: clearAll() results in strokes.length === 0</verification>
    </criterion>
    <criterion id="AC-4.2.8" priority="must">
      Strokes stored with normalized [0,1] coordinates
      <verification>Test: all Point.x and Point.y values are in range [0, 1]</verification>
    </criterion>
  </acceptanceCriteria>

  <!-- ==================== DOCUMENTATION ARTIFACTS ==================== -->
  <artifacts type="docs">
    
    <artifact name="Tech Spec Epic 4" path="docs/sprint-artifacts/tech-spec-epic-4.md">
      <relevantSections>
        <section name="Annotation Store Design" lines="207-252">
          Defines the AnnotationState interface with:
          - strokes: Stroke[]
          - activeStroke: Stroke | null
          - activeTool: Tool ('select' | 'pen' | 'highlighter' | 'eraser')
          - Actions: addStroke, updateStroke, completeStroke, deleteStroke, clearAll, setActiveTool, setActiveStroke, setStrokes
          - Selectors: getStrokesByParticipant, getCompletedStrokes
        </section>
        <section name="Data Models" lines="210-225">
          Point interface: { x: number, y: number, pressure?: number }
          Stroke interface: { id, participantId, tool, color, points, createdAt, isComplete }
          NOTE: isComplete field required but not yet in shared types - add to types/stroke.ts
        </section>
        <section name="Recommended Order" lines="943-957">
          Story 4.2 is FIRST in implementation order - it is the foundation for all other stories
        </section>
      </relevantSections>
    </artifact>

    <artifact name="Architecture" path="docs/architecture.md">
      <relevantSections>
        <section name="State Management">
          ADR-004: Zustand over Redux for lightweight state management
          Pattern: Create separate stores per domain (roomStore, screenShareStore, annotationStore)
        </section>
      </relevantSections>
    </artifact>

  </artifacts>

  <!-- ==================== CODE ARTIFACTS ==================== -->
  <artifacts type="code">

    <artifact name="Stroke Types" path="packages/shared/src/types/stroke.ts" importance="critical">
      <currentImplementation>
        <![CDATA[
/**
 * Normalized point for resolution-independent coordinates.
 * All values are in the range [0.0, 1.0] representing
 * relative position on the canvas.
 */
export interface Point {
  /** X coordinate, normalized [0.0 - 1.0] */
  x: number
  /** Y coordinate, normalized [0.0 - 1.0] */
  y: number
  /** Optional pressure value for pressure-sensitive input */
  pressure?: number
}

/**
 * A stroke represents a single continuous drawing action.
 * Used for annotations on shared screens.
 */
export interface Stroke {
  /** Unique identifier for the stroke */
  id: string
  /** ID of the participant who created this stroke */
  participantId: string
  /** Drawing tool used */
  tool: 'pen' | 'highlighter'
  /** Hex color string for the stroke */
  color: string
  /** Array of points making up the stroke path */
  points: Point[]
  /** Unix timestamp in milliseconds when stroke was created */
  createdAt: number
}
        ]]>
      </currentImplementation>
      <requiredChanges>
        <change type="add-field">
          Add isComplete: boolean field to Stroke interface
          Purpose: Track whether stroke is finalized (mouse up) vs in-progress
        </change>
      </requiredChanges>
    </artifact>

    <artifact name="Room Store Pattern" path="packages/client/src/stores/roomStore.ts" importance="high">
      <pattern>
        <![CDATA[
// Pattern for Zustand store with typed state and actions
import { create } from 'zustand'

interface RoomState {
  // State fields
  currentRoom: RoomInfo | null
  isConnecting: boolean
  
  // Actions
  setCurrentRoom: (room: RoomInfo | null) => void
  clearRoom: () => void
}

const initialState = {
  currentRoom: null,
  isConnecting: false,
}

export const useRoomStore = create<RoomState>((set) => ({
  ...initialState,
  
  setCurrentRoom: (room) => set({ currentRoom: room }),
  
  clearRoom: () => set(initialState),
}))
        ]]>
      </pattern>
      <notes>
        - Use create() from zustand
        - Define interface for state + actions
        - Separate initialState object for reset functionality
        - Export hook with "use" prefix (useAnnotationStore)
      </notes>
    </artifact>

    <artifact name="Screen Share Store Pattern" path="packages/client/src/stores/screenShareStore.ts" importance="medium">
      <pattern>
        <![CDATA[
// Pattern for simple domain store
import { create } from 'zustand'

export interface ScreenShareState {
  // State
  isSharing: boolean
  sharerId: string | null
  
  // Actions
  startSharing: (source: 'screen' | 'window', sourceId: string) => void
  stopSharing: () => void
}

const defaultState = {
  isSharing: false,
  sharerId: null as string | null,
}

export const useScreenShareStore = create<ScreenShareState>((set) => ({
  ...defaultState,
  
  startSharing: (source, sourceId) =>
    set({
      isSharing: true,
      sharedSource: source,
    }),
  
  stopSharing: () => set(defaultState),
}))
        ]]>
      </pattern>
    </artifact>

    <artifact name="Participant Colors" path="packages/shared/src/constants/colors.ts" importance="medium">
      <content>
        <![CDATA[
export const PARTICIPANT_COLORS = [
  '#f97316', // Orange (first participant/host)
  '#06b6d4', // Cyan
  '#a855f7', // Purple
  '#22c55e', // Green
  '#ec4899', // Pink
] as const

export type ParticipantColor = (typeof PARTICIPANT_COLORS)[number]
        ]]>
      </content>
    </artifact>

    <artifact name="AnnotationCanvas Integration" path="packages/client/src/components/AnnotationCanvas/AnnotationCanvas.tsx" importance="high">
      <notes>
        Story 4.1 implemented AnnotationCanvas which accepts:
        - strokes: Stroke[] (completed strokes)
        - activeStroke: Stroke | null (in-progress stroke)
        
        The annotationStore will provide these values to AnnotationCanvas.
        AnnotationCanvas renders strokes using perfect-freehand library.
      </notes>
    </artifact>

  </artifacts>

  <!-- ==================== DEPENDENCIES ==================== -->
  <dependencies>
    <runtime>
      <dependency name="zustand" version="^5.0.9" purpose="State management">
        Already installed in packages/client/package.json
      </dependency>
      <dependency name="@etch/shared" version="workspace:*" purpose="Shared types (Stroke, Point)">
        Already configured as workspace dependency
      </dependency>
    </runtime>
    <testing>
      <dependency name="vitest" version="^2.0.0" purpose="Unit testing">
        Already installed
      </dependency>
      <dependency name="@testing-library/react" version="^16.3.0" purpose="React testing utilities">
        Use act() for state updates in tests
      </dependency>
    </testing>
  </dependencies>

  <!-- ==================== CONSTRAINTS ==================== -->
  <constraints>
    <constraint type="file-location">
      Store file: packages/client/src/stores/annotationStore.ts
      Test file: packages/client/tests/stores/annotationStore.test.ts
    </constraint>
    <constraint type="pattern">
      Follow existing Zustand store pattern from roomStore.ts and screenShareStore.ts
    </constraint>
    <constraint type="types">
      Import Stroke, Point from @etch/shared
      Define Tool type locally: 'select' | 'pen' | 'highlighter' | 'eraser'
    </constraint>
    <constraint type="naming">
      Export store hook as useAnnotationStore (following existing convention)
    </constraint>
    <constraint type="coordinates">
      All Point coordinates must be normalized [0, 1] range
      Validation not required in store (trust input from hooks)
    </constraint>
    <constraint type="initialization">
      Default activeTool should be 'pen' (per AC-4.3.9)
      Default strokes should be empty array
      Default activeStroke should be null
    </constraint>
  </constraints>

  <!-- ==================== INTERFACES TO IMPLEMENT ==================== -->
  <interfaces>
    
    <interface name="AnnotationState">
      <![CDATA[
// Tool type (define in annotationStore.ts)
export type Tool = 'select' | 'pen' | 'highlighter' | 'eraser'

// Main store interface
interface AnnotationState {
  // ─────────────────────────────────────────────────────────
  // STATE FIELDS
  // ─────────────────────────────────────────────────────────
  
  /** Array of completed strokes (mouse up has occurred) */
  strokes: Stroke[]
  
  /** Currently in-progress stroke (mouse is down, drawing) */
  activeStroke: Stroke | null
  
  /** Currently selected tool */
  activeTool: Tool
  
  // ─────────────────────────────────────────────────────────
  // STROKE ACTIONS
  // ─────────────────────────────────────────────────────────
  
  /** Add a new completed stroke to the strokes array */
  addStroke: (stroke: Stroke) => void
  
  /** Append points to an existing stroke (for remote updates) */
  updateStroke: (strokeId: string, points: Point[]) => void
  
  /** Mark a stroke as complete (isComplete: true) */
  completeStroke: (strokeId: string) => void
  
  /** Remove a stroke by ID (eraser tool) */
  deleteStroke: (strokeId: string) => void
  
  /** Clear all strokes (host only, via clear button) */
  clearAll: () => void
  
  // ─────────────────────────────────────────────────────────
  // TOOL ACTIONS
  // ─────────────────────────────────────────────────────────
  
  /** Set the currently active tool */
  setActiveTool: (tool: Tool) => void
  
  // ─────────────────────────────────────────────────────────
  // ACTIVE STROKE ACTIONS
  // ─────────────────────────────────────────────────────────
  
  /** Set or clear the active (in-progress) stroke */
  setActiveStroke: (stroke: Stroke | null) => void
  
  // ─────────────────────────────────────────────────────────
  // BULK OPERATIONS (late-joiner sync)
  // ─────────────────────────────────────────────────────────
  
  /** Replace all strokes (for late-joiner state snapshot) */
  setStrokes: (strokes: Stroke[]) => void
  
  // ─────────────────────────────────────────────────────────
  // SELECTORS (derived state)
  // ─────────────────────────────────────────────────────────
  
  /** Get strokes filtered by participant ID */
  getStrokesByParticipant: (participantId: string) => Stroke[]
  
  /** Get only completed strokes (isComplete: true) */
  getCompletedStrokes: () => Stroke[]
}
      ]]>
    </interface>

    <interface name="Stroke (with isComplete)">
      <![CDATA[
// Update to packages/shared/src/types/stroke.ts
export interface Stroke {
  id: string
  participantId: string
  tool: 'pen' | 'highlighter'
  color: string
  points: Point[]
  createdAt: number
  isComplete: boolean  // <-- ADD THIS FIELD
}
      ]]>
    </interface>

  </interfaces>

  <!-- ==================== TEST STRATEGY ==================== -->
  <tests>
    <testFile path="packages/client/tests/stores/annotationStore.test.ts">
      <pattern>
        Follow existing store test patterns (see roomStore.test.ts):
        - Use beforeEach to reset store state
        - Use act() from @testing-library/react for state updates
        - Group tests by describe() blocks (state, actions, selectors)
        - Test edge cases (empty arrays, non-existent IDs)
      </pattern>
      <requiredTests>
        <test name="initial state">strokes is empty array, activeStroke is null, activeTool is 'pen'</test>
        <test name="addStroke">adds stroke to strokes array</test>
        <test name="addStroke duplicate">handles adding stroke with same ID</test>
        <test name="updateStroke">appends points to existing stroke</test>
        <test name="updateStroke non-existent">handles updating non-existent stroke</test>
        <test name="completeStroke">sets isComplete: true on stroke</test>
        <test name="deleteStroke">removes stroke by ID</test>
        <test name="deleteStroke non-existent">handles deleting non-existent stroke</test>
        <test name="clearAll">empties strokes array</test>
        <test name="clearAll preserves activeTool">does not change activeTool</test>
        <test name="setActiveTool">updates activeTool state</test>
        <test name="setActiveStroke">sets active stroke</test>
        <test name="setActiveStroke null">clears active stroke</test>
        <test name="setStrokes">replaces all strokes (bulk update)</test>
        <test name="getStrokesByParticipant">returns only matching strokes</test>
        <test name="getStrokesByParticipant empty">returns empty for non-existent participant</test>
        <test name="getCompletedStrokes">returns only strokes with isComplete: true</test>
        <test name="coordinates normalized">strokes maintain [0,1] coordinate range</test>
      </requiredTests>
    </testFile>
    
    <testHelpers>
      <![CDATA[
// Factory functions for test data
const createMockPoint = (overrides?: Partial<Point>): Point => ({
  x: 0.5,
  y: 0.5,
  pressure: 0.5,
  ...overrides,
})

const createMockStroke = (overrides?: Partial<Stroke>): Stroke => ({
  id: `stroke-${Date.now()}`,
  participantId: 'participant-1',
  tool: 'pen',
  color: '#f97316',
  points: [createMockPoint()],
  createdAt: Date.now(),
  isComplete: false,
  ...overrides,
})
      ]]>
    </testHelpers>
  </tests>

  <!-- ==================== IMPLEMENTATION NOTES ==================== -->
  <notes>
    <note priority="high">
      FIRST: Update packages/shared/src/types/stroke.ts to add isComplete field
      This is a prerequisite for the store implementation
    </note>
    <note priority="high">
      Store is FOUNDATION for all Epic 4 stories - keep interface stable
    </note>
    <note priority="medium">
      getStrokesByParticipant and getCompletedStrokes should be derived functions
      using get() in Zustand (not stored state)
    </note>
    <note priority="medium">
      For updateStroke, append new points to existing points array (don't replace)
      This supports incremental stroke updates from DataTrack sync
    </note>
    <note priority="low">
      Consider using immer middleware later if mutations become complex
      For now, simple spread operators are sufficient
    </note>
  </notes>

  <!-- ==================== TASK BREAKDOWN (from story file) ==================== -->
  <tasks>
    <task id="1" name="Update Stroke type to add isComplete field">
      File: packages/shared/src/types/stroke.ts
      Add: isComplete: boolean
    </task>
    <task id="2" name="Create annotationStore.ts file">
      File: packages/client/src/stores/annotationStore.ts
      Define: Tool type, AnnotationState interface, initialState, useAnnotationStore
    </task>
    <task id="3" name="Implement stroke state (strokes array)">
      Initial value: []
      Actions: addStroke, deleteStroke, clearAll, setStrokes
    </task>
    <task id="4" name="Implement activeStroke state">
      Initial value: null
      Actions: setActiveStroke
    </task>
    <task id="5" name="Implement activeTool state">
      Initial value: 'pen'
      Actions: setActiveTool
    </task>
    <task id="6" name="Implement updateStroke action">
      Appends new points to existing stroke's points array
    </task>
    <task id="7" name="Implement completeStroke action">
      Sets isComplete: true for specified stroke
    </task>
    <task id="8" name="Implement selector functions">
      getStrokesByParticipant, getCompletedStrokes
    </task>
    <task id="9" name="Write unit tests">
      File: packages/client/tests/stores/annotationStore.test.ts
      Cover all actions and selectors with 90%+ coverage
    </task>
    <task id="10" name="Verify TypeScript compilation">
      Run: pnpm tsc --noEmit in packages/client
    </task>
  </tasks>

</storyContext>

