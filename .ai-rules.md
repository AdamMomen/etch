# AI Rules for NAMELESS Development

This document defines rules and guidelines for AI-assisted development on the NAMELESS project.

## General Principles

1. **Code Quality First**: Always prioritize clean, maintainable, and well-tested code
2. **User Experience**: Every feature should enhance the meeting and annotation experience
3. **Open Source Mindset**: Write code that others can understand and contribute to
4. **Real-time Performance**: Optimize for low latency (<200ms annotation latency target)
5. **Separation of Concerns**: Keep media transport (LiveKit) separate from annotation logic
6. **Desktop-First**: Prioritize macOS and Windows desktop experience
7. **Commercial-Friendly**: Apache 2.0 license allows commercial use

## Meeting Platform Specific Rules

### Meeting Management
- Support 10-20 participants per room (v1 target)
- Real-time synchronization via LiveKit SFU
- Handle network interruptions gracefully
- Support audio, video, and screen-share
- Desktop-first experience (Electron app)

### Annotation System Architecture
- **Vector-Based Events**: Transmit stroke metadata only, never pixel data
- **Coordinate Normalization**: Use [0,1] normalized coordinates for resolution independence
- **Event-Driven**: Use LiveKit DataTracks for annotation synchronization
- **Local Rendering**: Each client renders annotations locally for <200ms latency
- **Canvas Overlay**: Render annotations on separate canvas layer over video element
- **Late Joiners**: Implement sync_request/sync_state for state hydration

### Annotation Protocol
- **stroke_add**: New stroke with points array, ownerId, color, width
- **stroke_end**: Signal completion of a stroke
- **stroke_delete**: Remove stroke (with ownership check)
- **clear_all**: Host/sharer can clear all annotations
- **sync_request**: Request current state when joining
- **sync_state**: Response with all current strokes

### Role-Based Permissions
- **Host**: Enable/disable annotations, clear all, manage users
- **Sharer**: Share screen, delete any stroke
- **Annotator**: Create/delete own strokes only
- **Viewer**: View-only (no annotation authoring)
- Enforce permissions at App Server level (token metadata)

### Data Handling
- Respect user privacy (self-hostable for data control)
- Implement proper data retention policies
- Support data export
- Comply with relevant regulations (GDPR, etc.)
- No persistent storage of annotations in v1 (session-only)

### Tech Stack Constraints
- **Desktop Client**: Electron + React + TypeScript
- **Media Backend**: LiveKit SFU + DataTracks (self-hosted or cloud)
- **App Server**: Node.js or Go (choose one, be consistent)
- **Annotation Transport**: LiveKit DataTracks (WebRTC DataChannel)
- **Future Native**: Rust/Swift/C++ for OS-level overlays (not v1)

### v1 Non-Goals (Do NOT Implement)
- ❌ PSTN/phone dial-in
- ❌ Browser annotation tools (view-only web is fine)
- ❌ OS-level ink overlays (future feature)
- ❌ Complex shapes/whiteboards (keep simple: draw, highlight, basic shapes)
- ❌ Recording & replay (future feature)

## Code Generation Rules

### When generating code:
1. Always include TypeScript types
2. Add error handling
3. Include input validation
4. Write tests alongside code
5. Add JSDoc comments for public APIs
6. Consider edge cases and error scenarios

### When refactoring:
1. Maintain backward compatibility when possible
2. Update tests to reflect changes
3. Update documentation
4. Consider performance implications

## Testing Rules

- Write tests before or alongside implementation
- Use descriptive test names
- Test both happy paths and edge cases
- Mock external dependencies
- Keep tests fast and independent

## Documentation Rules

- Document "why" not just "what"
- Include usage examples
- Keep documentation up to date
- Use clear, concise language
- Document breaking changes

## Security Rules

- Never commit secrets or API keys
- Validate and sanitize all user inputs
- Use parameterized queries for database operations
- Implement rate limiting
- Follow principle of least privilege
- Regular security audits

## Performance Rules

- **Critical Target**: Annotation latency < 200ms end-to-end
- **Scalability**: Design for 10-20 participants per room
- Profile before optimizing
- Optimize critical paths first (annotation rendering, DataTrack sync)
- Use lazy loading for non-critical features
- Implement proper caching
- Monitor performance metrics (latency, frame rate, memory)
- Set performance budgets
- Prioritize low-latency over perfect visual quality
- Use normalized coordinates to avoid resolution-dependent calculations

## Accessibility Rules

- Test with keyboard navigation
- Ensure proper focus management
- Use semantic HTML
- Provide alternative text for images
- Test with screen readers
- Follow WCAG guidelines

## Git & Collaboration Rules

- Write clear commit messages
- Keep commits focused and atomic
- Use conventional commit format
- Create meaningful PR descriptions
- Review code thoroughly before merging
- Respond to feedback constructively

